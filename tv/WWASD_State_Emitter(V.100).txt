//@version=6
indicator("WWASD_State_Emitter", overlay=true, scale=scale.none)

// ───────────────────────── Inputs (existing keep) ─────────────────────────
useDailyVWAP = input.bool(true, "Include Daily VWAP checks")
lookback     = input.int(20, "Structure Lookback (bars)", minval=5)

// ───────────────────────── New inputs (append-only) ─────────────────────────
group_rsi = "RSI (Daily)"
rsiLen    = input.int(14, "RSI Length", minval=2, group=group_rsi)
rsiOB     = input.int(70, "Overbought", minval=50, maxval=100, group=group_rsi)
rsiOS     = input.int(30, "Oversold",  minval=0,  maxval=50,  group=group_rsi)
rsiDivLen = input.int(10, "Divergence Pivot Len (daily)", minval=2, group=group_rsi)

// APPEND-ONLY: Indicator Blend (LTF rating drivers)
group_ind  = "Indicator Blend (LTF)"
mpvwap_anchor = input.string("Q", "MP-VWAP Anchor", options=["W","M","Q","Y"], group=group_ind)
rsi_tf       = input.string("1D", "RSI timeframe", options=["5","15","60","240","1D"], group=group_ind)
ob_enabled   = input.bool(false, "Order Blocks — enabled", group=group_ind)
ob_tf        = input.string("60", "Order Blocks — timeframe", options=["5","15","60","240","1D"], group=group_ind)
useEma12Rate = input.bool(true, "Include 1D EMA-12 in rating", group=group_ind)

// Weights and scaling (0..1 weights; kv/ke are ATR scalers)
w_vwap = input.float(0.50, "w_vwap", minval=0.0, maxval=1.0, step=0.05, group=group_ind)
w_rsi  = input.float(0.50, "w_rsi",  minval=0.0, maxval=1.0, step=0.05, group=group_ind)
w_ema  = input.float(0.50, "w_ema",  minval=0.0, maxval=1.0, step=0.05, group=group_ind)
w_ob   = input.float(0.25, "w_ob",   minval=0.0, maxval=1.0, step=0.05, group=group_ind)
kv     = input.float(1.00, "kv (VWAP/ATR)", minval=0.1, maxval=10.0, step=0.1, group=group_ind)
ke     = input.float(1.00, "ke (EMA/ATR)",  minval=0.1, maxval=10.0, step=0.1, group=group_ind)

group_steak = "Steak (1D 12-EMA + QVWAP)"
qvwapAtrK   = input.float(0.50, "QVWAP ATR factor (band = ATR*factor)", minval=0.1, maxval=2.0, step=0.05, group=group_steak)

group_bias  = "Bias (Monday range only)"
useDO       = input.bool(true,  "Emit Daily-Open state", group=group_bias)   // ← restored (no DO removal)
useMon      = input.bool(true,  "Emit Monday range state", group=group_bias)

group_macro = "Macro (OTHERS vs STABLE)"
othersSym   = input.symbol("CRYPTOCAP:OTHERS.D",   "OTHERS.D",     group=group_macro)
stableSym   = input.symbol("CRYPTOCAP:STABLE.C.D", "STABLE.C.D",   group=group_macro)
macroDead   = input.float(0.20, "Dead-zone % (treat as flat)", minval=0, step=0.05, group=group_macro)
macroWeight = input.float(0.8, "Macro weight in rating", minval=0.0, maxval=1.0, step=0.1, group=group_macro)

group_alert = "Alerts / Guards"
dedupeBarsD = input.int(3, "A+ dedupe (daily bars)", minval=1, group=group_alert)

// ───────────────────────── Helpers ─────────────────────────
boolToStr(b) => b ? "true" : "false"
fmt1(x) => str.tostring(math.round(x*10.0)/10.0)
// APPEND-ONLY: hyperbolic tangent helper for Pine v6
tanh(x) =>
    e2 = math.exp(2.0 * x)
    (e2 - 1.0) / (e2 + 1.0)

// pct change helper for macro
pct_change_daily(sym) =>
    c  = request.security(sym, "D", close,    barmerge.gaps_off, barmerge.lookahead_off)
    c1 = request.security(sym, "D", close[1], barmerge.gaps_off, barmerge.lookahead_off)
    na(c) or na(c1) or c1 == 0 ? 0.0 : ((c - c1) / c1) * 100.0

// ===================== 5m (added) =====================
var float lastPH_5 = na
var float prevPH_5 = na
var float lastPL_5 = na
var float prevPL_5 = na

ph_5 = request.security(syminfo.tickerid, "5", ta.pivothigh(high, lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)
pl_5 = request.security(syminfo.tickerid, "5", ta.pivotlow (low,  lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)

if not na(ph_5) and ph_5 != lastPH_5
    prevPH_5 := lastPH_5
    lastPH_5 := ph_5
if not na(pl_5) and pl_5 != lastPL_5
    prevPL_5 := lastPL_5
    lastPL_5 := pl_5

hh_5 = not na(lastPH_5) and not na(prevPH_5) and lastPH_5 > prevPH_5
hl_5 = not na(lastPL_5) and not na(prevPL_5) and lastPL_5 > prevPL_5
lh_5 = not na(lastPH_5) and not na(prevPH_5) and lastPH_5 < prevPH_5
ll_5 = not na(lastPL_5) and not na(prevPL_5) and lastPL_5 < prevPL_5

close_5     = request.security(syminfo.tickerid, "5", close,              barmerge.gaps_off, barmerge.lookahead_off)
ema100_5    = request.security(syminfo.tickerid, "5", ta.ema(close, 100), barmerge.gaps_off, barmerge.lookahead_off)
ema_state_5 = close_5 > ema100_5 ? "above" : "below"

// ───────────────────────── Original 15m block (with fix) ─────────────────────────
ema100_15    = ta.ema(close, 100)
ema_state_15 = close > ema100_15 ? "above" : "below"

var float lastPH_15 = na
var float prevPH_15 = na
var float lastPL_15 = na
var float prevPL_15 = na

ph_15 = request.security(syminfo.tickerid, "15", ta.pivothigh(high, lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)
pl_15 = request.security(syminfo.tickerid, "15", ta.pivotlow (low,  lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)

if not na(ph_15) and ph_15 != lastPH_15
    prevPH_15 := lastPH_15
    lastPH_15 := ph_15
// FIX: compare pl_15 to lastPL_15 (not ph_15 to lastPH_15)
if not na(pl_15) and pl_15 != lastPL_15
    prevPL_15 := lastPL_15
    lastPL_15 := pl_15

hh_15 = not na(lastPH_15) and not na(prevPH_15) and lastPH_15 > prevPH_15
hl_15 = not na(lastPL_15) and not na(prevPL_15) and lastPL_15 > prevPL_15
lh_15 = not na(lastPH_15) and not na(prevPH_15) and lastPH_15 < prevPH_15
ll_15 = not na(lastPL_15) and not na(prevPL_15) and lastPL_15 < prevPL_15

// ───────────────────────── Original 60m block (unchanged) ─────────────────────────
var float lastPH_60 = na
var float prevPH_60 = na
var float lastPL_60 = na
var float prevPL_60 = na

ph_60 = request.security(syminfo.tickerid, "60", ta.pivothigh(high, lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)
pl_60 = request.security(syminfo.tickerid, "60", ta.pivotlow (low,  lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)

if not na(ph_60) and ph_60 != lastPH_60
    prevPH_60 := lastPH_60
    lastPH_60 := ph_60
if not na(pl_60) and pl_60 != lastPL_60
    prevPL_60 := lastPL_60
    lastPL_60 := pl_60

close_60     = request.security(syminfo.tickerid, "60", close,              barmerge.gaps_off, barmerge.lookahead_off)
ema100_60    = request.security(syminfo.tickerid, "60", ta.ema(close, 100), barmerge.gaps_off, barmerge.lookahead_off)
ema_state_60 = close_60 > ema100_60 ? "above" : "below"

hh_60 = not na(lastPH_60) and not na(prevPH_60) and lastPH_60 > prevPH_60
hl_60 = not na(lastPL_60) and not na(prevPL_60) and lastPL_60 > prevPL_60
lh_60 = not na(lastPH_60) and not na(prevPH_60) and lastPH_60 < prevPH_60
ll_60 = not na(lastPL_60) and not na(prevPL_60) and lastPL_60 < prevPL_60

// ───────────────────────── Original 240m block (unchanged) ─────────────────────────
var float lastPH_240 = na
var float prevPH_240 = na
var float lastPL_240 = na
var float prevPL_240 = na

ph_240 = request.security(syminfo.tickerid, "240", ta.pivothigh(high, lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)
pl_240 = request.security(syminfo.tickerid, "240", ta.pivotlow (low,  lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)

if not na(ph_240) and ph_240 != lastPH_240
    prevPH_240 := lastPH_240
    lastPH_240 := ph_240
if not na(pl_240) and pl_240 != lastPL_240
    prevPL_240 := lastPL_240
    lastPL_240 := pl_240

close_240     = request.security(syminfo.tickerid, "240", close,              barmerge.gaps_off, barmerge.lookahead_off)
ema100_240    = request.security(syminfo.tickerid, "240", ta.ema(close, 100), barmerge.gaps_off, barmerge.lookahead_off)
ema_state_240 = close_240 > ema100_240 ? "above" : "below"

hh_240 = not na(lastPH_240) and not na(prevPH_240) and lastPH_240 > prevPH_240
hl_240 = not na(lastPL_240) and not na(prevPL_240) and lastPL_240 > prevPL_240
lh_240 = not na(lastPH_240) and not na(prevPH_240) and lastPH_240 < prevPH_240
ll_240 = not na(lastPL_240) and not na(prevPL_240) and lastPL_240 < prevPL_240

// ───────────────────────── Original 1D block (kept + steak tags) ─────────────────────────
var float lastPH_D = na
var float prevPH_D = na
var float lastPL_D = na
var float prevPL_D = na

ph_D = request.security(syminfo.tickerid, "D", ta.pivothigh(high, lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)
pl_D = request.security(syminfo.tickerid, "D", ta.pivotlow (low,  lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)

if not na(ph_D) and ph_D != lastPH_D
    prevPH_D := lastPH_D
    lastPH_D := ph_D
if not na(pl_D) and pl_D != lastPL_D
    prevPL_D := lastPL_D
    lastPL_D := pl_D

close_D      = request.security(syminfo.tickerid, "D", close,              barmerge.gaps_off, barmerge.lookahead_off)
ema100_D     = request.security(syminfo.tickerid, "D", ta.ema(close, 100), barmerge.gaps_off, barmerge.lookahead_off)
ema12_D      = request.security(syminfo.tickerid, "D", ta.ema(close, 12),  barmerge.gaps_off, barmerge.lookahead_off)
close_D_1    = request.security(syminfo.tickerid, "D", close[1],           barmerge.gaps_off, barmerge.lookahead_off)
ema12_D_1    = request.security(syminfo.tickerid, "D", ta.ema(close, 12)[1], barmerge.gaps_off, barmerge.lookahead_off)

ema_state_D   = close_D > ema100_D ? "above" : "below"
hh_D          = not na(lastPH_D) and not na(prevPH_D) and lastPH_D > prevPH_D
hl_D          = not na(lastPL_D) and not na(prevPL_D) and lastPL_D > prevPL_D
lh_D          = not na(lastPH_D) and not na(prevPH_D) and lastPH_D < prevPH_D
ll_D          = not na(lastPL_D) and not na(prevPL_D) and lastPL_D < prevPL_D
ema12_reclaim = close_D > ema12_D and close_D_1 <= ema12_D_1
ema12_loss    = close_D < ema12_D and close_D_1 >= ema12_D_1

ema12_state   = close_D > ema12_D ? "above" : "below"  // NEW explicit daily state
ema12_slopeUp = ema12_D > ema12_D_1
ema12_slopeDn = ema12_D < ema12_D_1

// ---- Daily VWAP (optional; original keep)
vwap_reclaim = useDailyVWAP ? request.security(syminfo.tickerid, "D", close > ta.vwap and close[1] <= ta.vwap, barmerge.gaps_off, barmerge.lookahead_off) : false
vwap_loss    = useDailyVWAP ? request.security(syminfo.tickerid, "D", close < ta.vwap and close[1] >= ta.vwap, barmerge.gaps_off, barmerge.lookahead_off) : false

// ---- RSI (Daily) and thresholds (upgraded to true daily)
rsiD         = request.security(syminfo.tickerid, "D", ta.rsi(close, rsiLen), barmerge.gaps_off, barmerge.lookahead_off)
rsi_overbought = rsiD > rsiOB
rsi_oversold   = rsiD < rsiOS
rsi_50_up    = rsiD > 50 and nz(rsiD[1]) <= 50
rsi_50_down  = rsiD < 50 and nz(rsiD[1]) >= 50

// Regular divergences at extremes only (daily)
phRSI = ta.pivothigh(rsiD, rsiDivLen, rsiDivLen)
plRSI = ta.pivotlow (rsiD, rsiDivLen, rsiDivLen)
phPX  = ta.pivothigh(close_D, rsiDivLen, rsiDivLen)
plPX  = ta.pivotlow (close_D, rsiDivLen, rsiDivLen)

var float prev_phRSI = na, var float last_phRSI = na
var float prev_phPX  = na, var float last_phPX  = na
var float prev_plRSI = na, var float last_plRSI = na
var float prev_plPX  = na, var float last_plPX  = na

if not na(phRSI) and not na(phPX)
    prev_phRSI := last_phRSI, last_phRSI := phRSI
    prev_phPX  := last_phPX,  last_phPX  := phPX
if not na(plRSI) and not na(plPX)
    prev_plRSI := last_plRSI, last_plRSI := plRSI
    prev_plPX  := last_plPX,  last_plPX  := plPX

reg_bear_div = not na(last_phRSI) and not na(prev_phRSI) and not na(last_phPX) and not na(prev_phPX) and (last_phPX > prev_phPX) and (last_phRSI < prev_phRSI) and (last_phRSI > rsiOB)
reg_bull_div = not na(last_plRSI) and not na(prev_plRSI) and not na(last_plPX) and not na(prev_plPX) and (last_plPX < prev_plPX) and (last_plRSI > prev_plRSI) and (last_plRSI < rsiOS)

// ───────────────────────── QVWAP (Quarterly-anchored, Daily) ─────────────────────────
qvwap_tuple() =>
    var float cumPV = na
    var float cumV  = na
    newQ = ta.change(time("3M")) != 0
    if newQ or na(cumPV) or na(cumV)
        cumPV := 0.0
        cumV  := 0.0
    cumPV += hlc3 * volume
    cumV  += volume
    vwap = cumV > 0 ? cumPV / cumV : na
    atr  = ta.atr(14)
    band = atr * qvwapAtrK
    slope = vwap - vwap[1]
    [vwap, band, slope]

[qvwapD, qBandD, qSlopeD] = request.security(syminfo.tickerid, "D", qvwap_tuple(), barmerge.gaps_off, barmerge.lookahead_off)

qv_above = close_D > (qvwapD + qBandD)
qv_below = close_D < (qvwapD - qBandD)
qv_mid_upper = not qv_above and close_D >= qvwapD
qv_mid_lower = not qv_below and close_D <  qvwapD

qv_state = qv_above     ? "above" :
           qv_mid_upper ? "mid_to_upper" :
           qv_mid_lower ? "mid_to_lower" : "below"

qv_reclaim = close_D > qvwapD and close_D_1 <= nz(qvwapD[1])
qv_loss    = close_D < qvwapD and close_D_1 >= nz(qvwapD[1])

qv_slopeUp = qSlopeD > 0
qv_slopeDn = qSlopeD < 0

// Flat slope penalty detector
atrD = request.security(syminfo.tickerid, "D", ta.atr(14), barmerge.gaps_off, barmerge.lookahead_off)
flatSlope = math.abs(qSlopeD) < (0.05 * atrD)  // 5% ATR band ≈ “flatish”

// ───────────────────────── Bias context (Monday) ─────────────────────────

[dDow, dHi, dLo] = request.security(syminfo.tickerid, "D", [dayofweek, high, low], barmerge.gaps_off, barmerge.lookahead_off)
isMon = dDow == dayofweek.monday
monHi = ta.valuewhen(isMon, dHi, 0)
monLo = ta.valuewhen(isMon, dLo, 0)
monInside = useMon and not na(monHi) and not na(monLo) ? (close_D <= monHi and close_D >= monLo) : false
monDevAbove = useMon and not na(monHi) and close_D > monHi
monDevBelow = useMon and not na(monLo) and close_D < monLo
var string mon_state = "inside"
var string mon_state_prev = "inside"
if barstate.isconfirmed
    mon_state_prev := mon_state
    mon_state := not useMon or (na(monHi) or na(monLo)) ? "inside" :
         monDevAbove ? "dev_above" :
         monDevBelow ? "dev_below" : "inside"
    if mon_state_prev != "inside" and mon_state == "inside"
        mon_state := "reclaim_inside"

// ───────────────────────── Macro trend (OTHERS vs STABLE) ─────────────────────────
oChg = pct_change_daily(othersSym)
sChg = pct_change_daily(stableSym)

sgn_gate(x) => x >  macroDead ?  1 : x < -macroDead ? -1 : 0
oPulse = sgn_gate(oChg)
sPulse = sgn_gate(sChg)

string trend_sig =
     (oPulse ==  1 and sPulse == -1) ? "BUY"  :
     (oPulse == -1 and sPulse ==  1) ? "SELL" :
     "HOLD"

// ───────────────────────── Ratings (v1) — daily only ─────────────────────────
// Structure flags
struct_long  = hh_D or hl_D
struct_short = lh_D or ll_D
struct_mixed = (struct_long and struct_short)

// Location credit (guardrail #1: both agree + supportive slope → +0.6; else +0.3)
loc_long_full  = (ema12_state=="above") and (qv_state=="above" or qv_state=="mid_to_upper") and (ema12_slopeUp and qv_slopeUp)
loc_short_full = (ema12_state=="below") and (qv_state=="below" or qv_state=="mid_to_lower") and (ema12_slopeDn and qv_slopeDn)
loc_long_half  = (ema12_state=="above" or (qv_state=="above" or qv_state=="mid_to_upper"))
loc_short_half = (ema12_state=="below" or (qv_state=="below" or qv_state=="mid_to_lower"))

locCred_long  = loc_long_full  ? 0.6 : (loc_long_half  ? 0.3 : 0.0)
locCred_short = loc_short_full ? 0.6 : (loc_short_half ? 0.3 : 0.0)

// Trigger credit (guardrail #2: only if structure is clean)
trig_long  = (rsi_50_up or reg_bull_div) and struct_long  and not struct_mixed
trig_short = (rsi_50_down or reg_bear_div) and struct_short and not struct_mixed

trigCred_long  = trig_long  ? 0.4 : 0.0
trigCred_short = trig_short ? 0.4 : 0.0

// Bias credit (Monday only — DO removed)
biasCred_long  = (useMon and mon_state == "reclaim_inside") ? 0.2 : 0.0
biasCred_short = (useMon and mon_state == "reclaim_inside") ? 0.2 : 0.0

// Macro credit
macroCred_long  = trend_sig == "BUY"  ? macroWeight : 0.0
macroCred_short = trend_sig == "SELL" ? macroWeight : 0.0

// Penalties
pen_chase_long  = (rsiD > rsiOB) ? 0.4 : 0.0
pen_chase_short = (rsiD < rsiOS) ? 0.4 : 0.0
pen_mid_flat    = ((qv_state=="mid_to_upper" or qv_state=="mid_to_lower") and flatSlope) ? 0.4 : 0.0
pen_mixed       = struct_mixed ? 0.6 : 0.0

pen_long  = pen_chase_long  + pen_mid_flat + pen_mixed
pen_short = pen_chase_short + pen_mid_flat + pen_mixed

// Raw component sums
raw_long  = macroCred_long  + (struct_long ? 0.6 : 0.0) + locCred_long  + trigCred_long  + biasCred_long  - pen_long
raw_short = macroCred_short + (struct_short? 0.6 : 0.0) + locCred_short + trigCred_short + biasCred_short - pen_short

// Normalize to 1..10  (range [-1.4, +2.6] → [1,10])
norm(r) =>
    rr = 1.0 + ((r + 1.4) / 4.0) * 9.0
    math.max(1.0, math.min(10.0, math.round(rr*10.0)/10.0))

rating_long  = norm(raw_long)
rating_short = norm(raw_short)

// Decide HTF signal + rating
htf_sig = rating_long > rating_short and rating_long >= 7.5 ? "BUY" :
          rating_short > rating_long and rating_short >= 7.5 ? "SELL" : "HOLD"
htf_rating = htf_sig == "BUY"  ? rating_long :
             htf_sig == "SELL" ? rating_short : math.max(rating_long, rating_short)

// APPEND-ONLY: TF-aware RSI, MP-VWAP, and simple OB classification for LTF indicator-based rating
// Map "1D" -> "D" for security()
rsi_tf_res = rsi_tf == "1D" ? "D" : rsi_tf
ob_tf_res  = ob_tf  == "1D" ? "D" : ob_tf

// TF-aware RSI value
rsi_val = request.security(syminfo.tickerid, rsi_tf_res, ta.rsi(close, rsiLen), barmerge.gaps_off, barmerge.lookahead_off)

// Multi-period anchored VWAP (MP-VWAP) computed on Daily with selectable anchor
mpvwap_calc() =>
    var float cumPV = na
    var float cumV  = na
    newSess = mpvwap_anchor == "W" ? (ta.change(time("W"))  != 0) :
               mpvwap_anchor == "M" ? (ta.change(time("M"))  != 0) :
               mpvwap_anchor == "Q" ? (ta.change(time("3M")) != 0) :
                                      (ta.change(time("12M"))!= 0)
    if newSess or na(cumPV) or na(cumV)
        cumPV := 0.0
        cumV  := 0.0
    cumPV += hlc3 * volume
    cumV  += volume
    cumV > 0 ? cumPV / cumV : na

mpvwapD = request.security(syminfo.tickerid, "D", mpvwap_calc(), barmerge.gaps_off, barmerge.lookahead_off)
mpvwap_above = close_D > mpvwapD

// Simple internal Order Block (OB) heuristic on selected TF
var float ob_lastHigh = na
var float ob_lastLow  = na
// Use a tight 5-bar swing definition for OB pivots
obLen = 5
ob_ph = request.security(syminfo.tickerid, ob_tf_res, ta.pivothigh(high, obLen, obLen), barmerge.gaps_off, barmerge.lookahead_off)
ob_pl = request.security(syminfo.tickerid, ob_tf_res, ta.pivotlow (low,  obLen, obLen), barmerge.gaps_off, barmerge.lookahead_off)
if not na(ob_ph) and ob_ph != ob_lastHigh
    ob_lastHigh := ob_ph
if not na(ob_pl) and ob_pl != ob_lastLow
    ob_lastLow := ob_pl
ob_close     = request.security(syminfo.tickerid, ob_tf_res, close,              barmerge.gaps_off, barmerge.lookahead_off)
// Simple rule per spec: reclaim above last swing high => bullish; loss below last swing low => bearish; else none
string ob_state = "none"
if ob_enabled
    if not na(ob_lastHigh) and ob_close > ob_lastHigh
        ob_state := "bullish"
    else if not na(ob_lastLow) and ob_close < ob_lastLow
        ob_state := "bearish"
    else
        ob_state := "none"
else
    ob_state := "none"

// Indicator scores for LTF rating (normalized)
score_vwap = tanh( (close_D - mpvwapD) / (atrD * kv) )
score_rsi  = math.max(-1.0, math.min(1.0, (rsi_val - 50.0) / 50.0))
score_ema  = tanh( (close_D - ema12_D) / (atrD * ke) )
score_ob   = ob_state == "bullish" ?  1.0 : ob_state == "bearish" ? -1.0 : 0.0

num = (w_vwap * score_vwap) + (w_rsi * score_rsi) + ((useEma12Rate ? w_ema : 0.0) * score_ema) + ((ob_enabled ? w_ob : 0.0) * score_ob)
den = (w_vwap) + (w_rsi) + (useEma12Rate ? w_ema : 0.0) + (ob_enabled ? w_ob : 0.0)
rating_ind = den > 0 ? (5.0 + 5.0 * (num / den)) : 5.0
rating_ind := math.max(0.0, math.min(10.0, rating_ind))

// ===================== LTF rating & signal (5m/15m/60m vote) =====================

// Structure vote (long/short) across 5m, 15m, 60m
lt_votes_long  = (hh_5 or hl_5  ? 1 : 0) + (hh_15 or hl_15 ? 1 : 0) + (hh_60 or hl_60 ? 1 : 0)
lt_votes_short = (lh_5 or ll_5  ? 1 : 0) + (lh_15 or ll_15 ? 1 : 0) + (lh_60 or ll_60 ? 1 : 0)

struct_long_ltf  = lt_votes_long  >= 2
struct_short_ltf = lt_votes_short >= 2
struct_mixed_ltf = struct_long_ltf and struct_short_ltf

// Triggers (reuse daily RSI/div rules but require clean structure)
trig_long_ltf   = (rsi_50_up   or reg_bull_div) and struct_long_ltf  and not struct_mixed_ltf
trig_short_ltf  = (rsi_50_down or reg_bear_div) and struct_short_ltf and not struct_mixed_ltf

trigCred_long_ltf   = trig_long_ltf  ? 0.4 : 0.0
trigCred_short_ltf  = trig_short_ltf ? 0.4 : 0.0

// Penalties (same recipe)
pen_mixed_ltf  = struct_mixed_ltf ? 0.6 : 0.0
pen_long_ltf   = pen_chase_long  + pen_mid_flat + pen_mixed_ltf
pen_short_ltf  = pen_chase_short + pen_mid_flat + pen_mixed_ltf

// Raw component sums (reuse macroCred_*, locCred_*, biasCred_*)
raw_long_ltf  = macroCred_long  + (struct_long_ltf  ? 0.6 : 0.0) + locCred_long  + trigCred_long_ltf  + biasCred_long  - pen_long_ltf
raw_short_ltf = macroCred_short + (struct_short_ltf ? 0.6 : 0.0) + locCred_short + trigCred_short_ltf + biasCred_short - pen_short_ltf

// Normalize to 1..10
ltf_rating_long  = norm(raw_long_ltf)
ltf_rating_short = norm(raw_short_ltf)

// LTF signal (same thresholds as HTF)
ltf_sig = ltf_rating_long > ltf_rating_short and ltf_rating_long >= 7.5 ? "BUY" :
          ltf_rating_short > ltf_rating_long and ltf_rating_short >= 7.5 ? "SELL" : "HOLD"

ltf_rating = ltf_sig == "BUY"  ? ltf_rating_long :
             ltf_sig == "SELL" ? ltf_rating_short : math.max(ltf_rating_long, ltf_rating_short)

// ───────────────────────── JSON assembly (original payload + new fields) ─────────────────────────
string oneDExtras = ""
if useDailyVWAP
    oneDExtras := ",\"vwap_reclaim\":" + boolToStr(vwap_reclaim) + ",\"vwap_loss\":" + boolToStr(vwap_loss)

// Keep original RSI keys but switched to real daily values
string rsiExtras = ",\"rsi\":" + str.tostring(rsiD) + ",\"rsi_overbought\":" + boolToStr(rsi_overbought) + ",\"rsi_oversold\":" + boolToStr(rsi_oversold)
// New RSI daily flags in 1D bucket (append-only)
string rsiFlags = ",\"rsi_50_up\":" + boolToStr(rsi_50_up) + ",\"rsi_50_down\":" + boolToStr(rsi_50_down) + ",\"rsi_bull_div\":" + boolToStr(reg_bull_div) + ",\"rsi_bear_div\":" + boolToStr(reg_bear_div)

// Steak tags appended in 1D bucket
string steakFlags = ",\"ema12_state\":\"" + ema12_state + "\",\"qvwap_state\":\"" + qv_state + "\",\"qvwap_reclaim\":" + boolToStr(qv_reclaim) + ",\"qvwap_loss\":" + boolToStr(qv_loss)

// (added) 5m in mtf
mtf_5   = "\"5\":{\"ema100_state\":\"" + ema_state_5   + "\"," + "\"hh\":" + boolToStr(hh_5)   + "," + "\"hl\":" + boolToStr(hl_5)   + "," + "\"lh\":" + boolToStr(lh_5)   + "," + "\"ll\":" + boolToStr(ll_5)   + "}"
mtf_15  = "\"15\":{\"ema100_state\":\"" + ema_state_15  + "\"," + "\"hh\":" + boolToStr(hh_15)  + "," + "\"hl\":" + boolToStr(hl_15)  + "," + "\"lh\":" + boolToStr(lh_15)  + "," + "\"ll\":" + boolToStr(ll_15)  + "}"
mtf_60  = "\"60\":{\"ema100_state\":\"" + ema_state_60  + "\"," + "\"hh\":" + boolToStr(hh_60)  + "," + "\"hl\":" + boolToStr(hl_60)  + "," + "\"lh\":" + boolToStr(lh_60)  + "," + "\"ll\":" + boolToStr(ll_60)  + "}"
mtf_240 = "\"240\":{\"ema100_state\":\"" + ema_state_240 + "\"," + "\"hh\":" + boolToStr(hh_240) + "," + "\"hl\":" + boolToStr(hl_240) + "," + "\"lh\":" + boolToStr(lh_240) + "," + "\"ll\":" + boolToStr(ll_240) + "}"
mtf_1D  = "\"1D\":{\"ema100_state\":\"" + ema_state_D   + "\"," + "\"hh\":" + boolToStr(hh_D)   + "," + "\"hl\":" + boolToStr(hl_D)   + "," + "\"lh\":" + boolToStr(lh_D)   + "," + "\"ll\":" + boolToStr(ll_D)   + "," + "\"ema12_reclaim\":" + boolToStr(ema12_reclaim) + "," + "\"ema12_loss\":" + boolToStr(ema12_loss) + steakFlags + oneDExtras + rsiExtras + rsiFlags + "}"

isFresh = "true"  // snapshot emitted once per bar close
ctxStr  = "\"ctx\":{\"above_do\":null,\"mon_state\":\"" + (useMon ? mon_state : "inside") + "\"}"

trendStr = "\"trend\":{" + "\"sig\":\"" + trend_sig + "\",\"source\":\"OTHERS_vs_STABLE\",\"others_d_change\":" + str.tostring(oChg) + ",\"stable_d_change\":" + str.tostring(sChg) + "}"

// Shared HTF components
compStr = "\"components\":{" +
          "\"macro\":" + fmt1(macroCred_long > 0 ? macroCred_long : macroCred_short) + "," +
          "\"structure\":" + fmt1(0.6) + "," +
          "\"location\":" + fmt1(htf_sig=="BUY"?locCred_long:htf_sig=="SELL"?locCred_short:0.0) + "," +
          "\"trigger\":" + fmt1(htf_sig=="BUY"?trigCred_long:htf_sig=="SELL"?trigCred_short:0.0) + "," +
          "\"bias\":" + fmt1(htf_sig=="BUY"?biasCred_long:htf_sig=="SELL"?biasCred_short:0.0) + "," +
          "\"penalty\":" + fmt1(htf_sig=="BUY"?(-pen_long):htf_sig=="SELL"?(-pen_short):0.0) + "}"

// NEW: LTF-specific components (keyed to ltf_sig)
compStr_ltf = "\"components\":{" +
           "\"macro\":" + fmt1(macroCred_long > 0 ? macroCred_long : macroCred_short) + "," +
           "\"structure\":" + fmt1(0.6) + "," +
           "\"location\":" + fmt1(ltf_sig=="BUY"?locCred_long:ltf_sig=="SELL"?locCred_short:0.0) + "," +
           "\"trigger\":" + fmt1(ltf_sig=="BUY"?trigCred_long_ltf:ltf_sig=="SELL"?trigCred_short_ltf:0.0) + "," +
           "\"bias\":" + fmt1(ltf_sig=="BUY"?biasCred_long:ltf_sig=="SELL"?biasCred_short:0.0) + "," +
           "\"penalty\":" + fmt1(ltf_sig=="BUY"?(-pen_long_ltf):ltf_sig=="SELL"?(-pen_short_ltf):0.0) + "}"

// APPEND-ONLY: Indicator capsule under ltf.comp.ind
indStr = "\"comp\":{\"ind\":{" +
         "\"mpvwap\":{\"anchor\":\"" + mpvwap_anchor + "\",\"v\":" + str.tostring(mpvwapD, format.mintick) + ",\"above\":" + boolToStr(mpvwap_above) + "}," +
         "\"rsi\":{\"tf\":\"" + rsi_tf + "\",\"len\":" + str.tostring(rsiLen) + ",\"v\":" + str.tostring(rsi_val, format.mintick) + "}," +
         "\"ema12_1d\":{\"v\":" + str.tostring(ema12_D, format.mintick) + ",\"above\":" + boolToStr(ema12_state=="above") + "}," +
         "\"ob\":{\"enabled\":" + boolToStr(ob_enabled) + ",\"tf\":\"" + ob_tf + "\",\"state\":\"" + ob_state + "\"}" +
         "}}"

// Final HTF/LTF objects
htfStr = "\"htf\":{" + "\"sig\":\"" + htf_sig + "\",\"rating\":" + fmt1(htf_rating) + "," + compStr + "}"
// FIX: components are now INSIDE ltf{} and object closes once
// APPEND-ONLY: keep existing rating math (v100 parity); only append comp.ind capsule
ltfStr = "\"ltf\":{" + "\"sig\":\"" + ltf_sig + "\",\"rating\":" + fmt1(ltf_rating) + "," + compStr_ltf + "," + indStr + "}"

// Final payload
payload = "{" + "\"type\":\"WWASD_STATE\"," + "\"symbol\":\"" + syminfo.ticker + "\"," + "\"tf_active\":\"" + timeframe.period + "\"," + "\"ts\":" + str.tostring(time) + "," + "\"cmp\":" + str.tostring(close, format.mintick) + "," + "\"is_fresh\":" + isFresh + "," + "\"mtf\":{" + mtf_5 + "," + mtf_15 + "," + mtf_60 + "," + mtf_240 + "," + mtf_1D + "}" + "," + ctxStr + "," + trendStr + "," + htfStr + "," + ltfStr + "}"

// ───────────────────────── Alerts ─────────────────────────

// Original per-bar snapshot alert (unchanged type / route behavior)
alertcondition(barstate.isconfirmed, title="WWASD Fire (per bar close)")
if barstate.isconfirmed
    alert(payload, alert.freq_once_per_bar_close)

// RSI events (optional, low-spam; daily only)
new_rsi50_up   = barstate.isconfirmed and rsi_50_up
new_rsi50_down = barstate.isconfirmed and rsi_50_down
new_bull_div   = barstate.isconfirmed and reg_bull_div
new_bear_div   = barstate.isconfirmed and reg_bear_div

rsi_evt = "{\"type\":\"WWASD_RSI_EVENT\",\"symbol\":\"" + syminfo.ticker + "\",\"tf\":\"1D\",\"evt\":\""
if new_rsi50_up
    alert(rsi_evt + "RSI_50_UP\"}", alert.freq_once_per_bar_close)
if new_rsi50_down
    alert(rsi_evt + "RSI_50_DOWN\"}", alert.freq_once_per_bar_close)
if new_bull_div
    alert(rsi_evt + "BULL_DIV\"}", alert.freq_once_per_bar_close)
if new_bear_div
    alert(rsi_evt + "BEAR_DIV\"}", alert.freq_once_per_bar_close)

// A+ candidate gate (dedupe 3 daily bars by default)
dIndex = request.security(syminfo.tickerid, "D", bar_index, barmerge.gaps_off, barmerge.lookahead_off)
var int lastA_Long  = na
var int lastA_Short = na
canEmitLong  = na(lastA_Long)  or (dIndex - lastA_Long  >= dedupeBarsD)
canEmitShort = na(lastA_Short) or (dIndex - lastA_Short >= dedupeBarsD)
aplus_long  = htf_sig=="BUY"  and (ltf_sig=="BUY"  or new_rsi50_up   or new_bull_div) and (useMon and mon_state=="reclaim_inside")
aplus_short = htf_sig=="SELL" and (ltf_sig=="SELL" or new_rsi50_down or new_bear_div) and (useMon and mon_state=="reclaim_inside")

if barstate.isconfirmed and aplus_long and canEmitLong
    lastA_Long := dIndex
    alert("{\"type\":\"WWASD_A_PLUS\",\"symbol\":\"" + syminfo.ticker + "\",\"dir\":\"LONG\",\"rating\":" + fmt1(htf_rating) + "}", alert.freq_once_per_bar_close)
if barstate.isconfirmed and aplus_short and canEmitShort
    lastA_Short := dIndex
    alert("{\"type\":\"WWASD_A_PLUS\",\"symbol\":\"" + syminfo.ticker + "\",\"dir\":\"SHORT\",\"rating\":" + fmt1(htf_rating) + "}", alert.freq_once_per_bar_close)
