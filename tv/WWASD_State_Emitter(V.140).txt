//@version=6
indicator("WWASD_State_Emitter", overlay=true, scale=scale.none)

// ───────────────────────── Inputs (existing keep) ─────────────────────────
useDailyVWAP = input.bool(true, "Include Daily VWAP checks")
lookback     = input.int(20, "Structure Lookback (bars)", minval=5)

// ───────────────────────── New inputs (append-only) ─────────────────────────
group_rsi = "RSI (Daily)"
rsiLen    = input.int(14, "RSI Length", minval=2, group=group_rsi)
rsiOB     = input.int(70, "Overbought", minval=50, maxval=100, group=group_rsi)
rsiOS     = input.int(30, "Oversold",  minval=0,  maxval=50,  group=group_rsi)
rsiDivLen = input.int(10, "Divergence Pivot Len (daily)", minval=2, group=group_rsi)

// APPEND-ONLY: Indicator Blend (LTF rating drivers)
group_ind  = "Indicator Blend (LTF)"
mpvwap_anchor = input.string("Q", "MP-VWAP Anchor", options=["W","M","Q","Y"], group=group_ind)
rsi_tf       = input.string("1D", "RSI timeframe", options=["5","15","60","240","1D"], group=group_ind)
ob_enabled   = input.bool(false, "Order Blocks — enabled", group=group_ind)
ob_tf        = input.string("60", "Order Blocks — timeframe", options=["5","15","60","240","1D"], group=group_ind)
useEma12Rate = input.bool(true, "Include 1D EMA-12 in rating", group=group_ind)

// APPEND-ONLY: Friendly MP-VWAP anchor toggle to mirror standalone indicator UI
mpvwap_anchor_ui = input.string("Quarter", "MP-VWAP Anchor (friendly)", options=["Week","Month","Quarter","Year"], group=group_ind)

// Weights and scaling (0..1 weights; kv/ke are ATR scalers)
w_vwap = input.float(0.50, "w_vwap", minval=0.0, maxval=1.0, step=0.05, group=group_ind)
w_rsi  = input.float(0.50, "w_rsi",  minval=0.0, maxval=1.0, step=0.05, group=group_ind)
w_ema  = input.float(0.50, "w_ema",  minval=0.0, maxval=1.0, step=0.05, group=group_ind)
w_ob   = input.float(0.25, "w_ob",   minval=0.0, maxval=1.0, step=0.05, group=group_ind)
kv     = input.float(1.00, "kv (VWAP/ATR)", minval=0.1, maxval=10.0, step=0.1, group=group_ind)
ke     = input.float(1.00, "ke (EMA/ATR)",  minval=0.1, maxval=10.0, step=0.1, group=group_ind)

group_steak = "Steak (1D 12-EMA + QVWAP)"
qvwapAtrK   = input.float(0.50, "QVWAP ATR factor (band = ATR*factor)", minval=0.1, maxval=2.0, step=0.05, group=group_steak)

group_bias  = "Bias (Monday range only)"
useDO       = input.bool(true,  "Emit Daily-Open state", group=group_bias)   // ← restored (no DO removal)
useMon      = input.bool(true,  "Emit Monday range state", group=group_bias)

group_macro = "Macro (OTHERS vs STABLE)"
othersSym   = input.symbol("CRYPTOCAP:OTHERS.D",   "OTHERS.D",     group=group_macro)
stableSym   = input.symbol("CRYPTOCAP:STABLE.C.D", "STABLE.C.D",   group=group_macro)
macroDead   = input.float(0.20, "Dead-zone % (treat as flat)", minval=0, step=0.05, group=group_macro)
macroWeight = input.float(0.0, "Macro weight in rating (0..0.3)", minval=0.0, maxval=0.3, step=0.05, group=group_macro)
macroSigThr   = input.float(7.0,  "Macro signal threshold (5..10)", minval=5.0, maxval=10.0, step=0.1, group=group_macro)
macroRecenter = input.float(0.35, "Recenter in chop (0..1)",        minval=0.0, maxval=1.0,  step=0.05, group=group_macro)
macroRSISym = input.symbol("CRYPTOCAP:TOTAL3", "Macro RSI Symbol (for trend)", group=group_macro)
macroRSILen = input.int(14, "Macro RSI Length (D)", minval=2, group=group_macro)
macroRSIpts = input.float(1.0, "Macro RSI nudge (±points)", minval=0.0, maxval=2.0, step=0.1, group=group_macro)


group_alert = "Alerts / Guards"
dedupeBarsD = input.int(3, "A+ dedupe (daily bars)", minval=1, group=group_alert)

// ───────────────────────── Helpers ─────────────────────────
boolToStr(b) => b ? "true" : "false"
fmt1(x) => str.tostring(math.round(x*10.0)/10.0)
tanh(x) =>
    e2 = math.exp(2.0 * x)
    (e2 - 1.0) / (e2 + 1.0)
// pct change helper for macro
pct_change_daily(sym) =>
    c  = request.security(sym, "D", close,    barmerge.gaps_off, barmerge.lookahead_off)
    c1 = request.security(sym, "D", close[1], barmerge.gaps_off, barmerge.lookahead_off)
    na(c) or na(c1) or c1 == 0 ? 0.0 : ((c - c1) / c1) * 100.0

// ===================== 5m (added) =====================
var float lastPH_5 = na
var float prevPH_5 = na
var float lastPL_5 = na
var float prevPL_5 = na

ph_5 = request.security(syminfo.tickerid, "5", ta.pivothigh(high, lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)
pl_5 = request.security(syminfo.tickerid, "5", ta.pivotlow (low,  lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)

if not na(ph_5) and ph_5 != lastPH_5
    prevPH_5 := lastPH_5
    lastPH_5 := ph_5
if not na(pl_5) and pl_5 != lastPL_5
    prevPL_5 := lastPL_5
    lastPL_5 := pl_5

hh_5 = not na(lastPH_5) and not na(prevPH_5) and lastPH_5 > prevPH_5
hl_5 = not na(lastPL_5) and not na(prevPL_5) and lastPL_5 > prevPL_5
lh_5 = not na(lastPH_5) and not na(prevPH_5) and lastPH_5 < prevPH_5
ll_5 = not na(lastPL_5) and not na(prevPL_5) and lastPL_5 < prevPL_5

close_5     = request.security(syminfo.tickerid, "5", close,              barmerge.gaps_off, barmerge.lookahead_off)
ema100_5    = request.security(syminfo.tickerid, "5", ta.ema(close, 100), barmerge.gaps_off, barmerge.lookahead_off)
ema_state_5 = close_5 > ema100_5 ? "above" : "below"

// ───────────────────────── Original 15m block (with fix) ─────────────────────────
ema100_15    = ta.ema(close, 100)
ema_state_15 = close > ema100_15 ? "above" : "below"

var float lastPH_15 = na
var float prevPH_15 = na
var float lastPL_15 = na
var float prevPL_15 = na

ph_15 = request.security(syminfo.tickerid, "15", ta.pivothigh(high, lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)
pl_15 = request.security(syminfo.tickerid, "15", ta.pivotlow (low,  lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)

if not na(ph_15) and ph_15 != lastPH_15
    prevPH_15 := lastPH_15
    lastPH_15 := ph_15
// FIX: compare pl_15 to lastPL_15 (not ph_15 to lastPH_15)
if not na(pl_15) and pl_15 != lastPL_15
    prevPL_15 := lastPL_15
    lastPL_15 := pl_15

hh_15 = not na(lastPH_15) and not na(prevPH_15) and lastPH_15 > prevPH_15
hl_15 = not na(lastPL_15) and not na(prevPL_15) and lastPL_15 > prevPL_15
lh_15 = not na(lastPH_15) and not na(prevPH_15) and lastPH_15 < prevPH_15
ll_15 = not na(lastPL_15) and not na(prevPL_15) and lastPL_15 < prevPL_15

// ───────────────────────── Original 60m block (unchanged) ─────────────────────────
var float lastPH_60 = na
var float prevPH_60 = na
var float lastPL_60 = na
var float prevPL_60 = na

ph_60 = request.security(syminfo.tickerid, "60", ta.pivothigh(high, lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)
pl_60 = request.security(syminfo.tickerid, "60", ta.pivotlow (low,  lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)

if not na(ph_60) and ph_60 != lastPH_60
    prevPH_60 := lastPH_60
    lastPH_60 := ph_60
if not na(pl_60) and pl_60 != lastPL_60
    prevPL_60 := lastPL_60
    lastPL_60 := pl_60

close_60     = request.security(syminfo.tickerid, "60", close,              barmerge.gaps_off, barmerge.lookahead_off)
ema100_60    = request.security(syminfo.tickerid, "60", ta.ema(close, 100), barmerge.gaps_off, barmerge.lookahead_off)
ema_state_60 = close_60 > ema100_60 ? "above" : "below"

hh_60 = not na(lastPH_60) and not na(prevPH_60) and lastPH_60 > prevPH_60
hl_60 = not na(lastPL_60) and not na(prevPL_60) and lastPL_60 > prevPL_60
lh_60 = not na(lastPH_60) and not na(prevPH_60) and lastPH_60 < prevPH_60
ll_60 = not na(lastPL_60) and not na(prevPL_60) and lastPL_60 < prevPL_60

// ───────────────────────── Original 240m block (unchanged) ─────────────────────────
var float lastPH_240 = na
var float prevPH_240 = na
var float lastPL_240 = na
var float prevPL_240 = na

ph_240 = request.security(syminfo.tickerid, "240", ta.pivothigh(high, lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)
pl_240 = request.security(syminfo.tickerid, "240", ta.pivotlow (low,  lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)

if not na(ph_240) and ph_240 != lastPH_240
    prevPH_240 := lastPH_240
    lastPH_240 := ph_240
if not na(pl_240) and pl_240 != lastPL_240
    prevPL_240 := lastPL_240
    lastPL_240 := pl_240

close_240     = request.security(syminfo.tickerid, "240", close,              barmerge.gaps_off, barmerge.lookahead_off)
ema100_240    = request.security(syminfo.tickerid, "240", ta.ema(close, 100), barmerge.gaps_off, barmerge.lookahead_off)
ema_state_240 = close_240 > ema100_240 ? "above" : "below"

hh_240 = not na(lastPH_240) and not na(prevPH_240) and lastPH_240 > prevPH_240
hl_240 = not na(lastPL_240) and not na(prevPL_240) and lastPL_240 > prevPL_240
lh_240 = not na(lastPH_240) and not na(prevPH_240) and lastPH_240 < prevPH_240
ll_240 = not na(lastPL_240) and not na(prevPL_240) and lastPL_240 < prevPL_240

// ───────────────────────── Original 1D block (kept + steak tags) ─────────────────────────
var float lastPH_D = na
var float prevPH_D = na
var float lastPL_D = na
var float prevPL_D = na

ph_D = request.security(syminfo.tickerid, "D", ta.pivothigh(high, lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)
pl_D = request.security(syminfo.tickerid, "D", ta.pivotlow (low,  lookback, lookback), barmerge.gaps_off, barmerge.lookahead_off)

if not na(ph_D) and ph_D != lastPH_D
    prevPH_D := lastPH_D
    lastPH_D := ph_D
if not na(pl_D) and pl_D != lastPL_D
    prevPL_D := lastPL_D
    lastPL_D := pl_D

close_D      = request.security(syminfo.tickerid, "D", close,              barmerge.gaps_off, barmerge.lookahead_off)
ema100_D     = request.security(syminfo.tickerid, "D", ta.ema(close, 100), barmerge.gaps_off, barmerge.lookahead_off)
ema12_D      = request.security(syminfo.tickerid, "D", ta.ema(close, 12),  barmerge.gaps_off, barmerge.lookahead_off)
close_D_1    = request.security(syminfo.tickerid, "D", close[1],           barmerge.gaps_off, barmerge.lookahead_off)
ema12_D_1    = request.security(syminfo.tickerid, "D", ta.ema(close, 12)[1], barmerge.gaps_off, barmerge.lookahead_off)

ema_state_D   = close_D > ema100_D ? "above" : "below"
hh_D          = not na(lastPH_D) and not na(prevPH_D) and lastPH_D > prevPH_D
hl_D          = not na(lastPL_D) and not na(prevPL_D) and lastPL_D > prevPL_D
lh_D          = not na(lastPH_D) and not na(prevPH_D) and lastPH_D < prevPH_D
ll_D          = not na(lastPL_D) and not na(prevPL_D) and lastPL_D < prevPL_D
ema12_reclaim = close_D > ema12_D and close_D_1 <= ema12_D_1
ema12_loss    = close_D < ema12_D and close_D_1 >= ema12_D_1

ema12_state   = close_D > ema12_D ? "above" : "below"  // NEW explicit daily state
ema12_slopeUp = ema12_D > ema12_D_1
ema12_slopeDn = ema12_D < ema12_D_1

// ---- Daily VWAP (optional; original keep)
vwap_reclaim = useDailyVWAP ? request.security(syminfo.tickerid, "D", close > ta.vwap and close[1] <= ta.vwap, barmerge.gaps_off, barmerge.lookahead_off) : false
vwap_loss    = useDailyVWAP ? request.security(syminfo.tickerid, "D", close < ta.vwap and close[1] >= ta.vwap, barmerge.gaps_off, barmerge.lookahead_off) : false

// ---- RSI (Daily) and thresholds (upgraded to true daily)
rsiD         = request.security(syminfo.tickerid, "D", ta.rsi(close, rsiLen), barmerge.gaps_off, barmerge.lookahead_off)
rsi_overbought = rsiD > rsiOB
rsi_oversold   = rsiD < rsiOS
rsi_50_up    = rsiD > 50 and nz(rsiD[1]) <= 50
rsi_50_down  = rsiD < 50 and nz(rsiD[1]) >= 50

// Regular divergences at extremes only (daily)
phRSI = ta.pivothigh(rsiD, rsiDivLen, rsiDivLen)
plRSI = ta.pivotlow (rsiD, rsiDivLen, rsiDivLen)
phPX  = ta.pivothigh(close_D, rsiDivLen, rsiDivLen)
plPX  = ta.pivotlow (close_D, rsiDivLen, rsiDivLen)

var float prev_phRSI = na, var float last_phRSI = na
var float prev_phPX  = na, var float last_phPX  = na
var float prev_plRSI = na, var float last_plRSI = na
var float prev_plPX  = na, var float last_plPX  = na

if not na(phRSI) and not na(phPX)
    prev_phRSI := last_phRSI, last_phRSI := phRSI
    prev_phPX  := last_phPX,  last_phPX  := phPX
if not na(plRSI) and not na(plPX)
    prev_plRSI := last_plRSI, last_plRSI := plRSI
    prev_plPX  := last_plPX,  last_plPX  := plPX

reg_bear_div = not na(last_phRSI) and not na(prev_phRSI) and not na(last_phPX) and not na(prev_phPX) and (last_phPX > prev_phPX) and (last_phRSI < prev_phRSI) and (last_phRSI > rsiOB)
reg_bull_div = not na(last_plRSI) and not na(prev_plRSI) and not na(last_plPX) and not na(prev_plPX) and (last_plPX < prev_plPX) and (last_plRSI > prev_plRSI) and (last_plRSI < rsiOS)

// ───────────────────────── QVWAP (Quarterly-anchored, 4H) ─────────────────────────
qvwap_tuple_4H() =>
    var float cumPV = na
    var float cumV  = na
    // reset at quarter boundaries (Jan/Apr/Jul/Oct)
    newM = ta.change(time("M")) != 0
    newQ = newM and (month == 1 or month == 4 or month == 7 or month == 10)
    if newQ or na(cumPV) or na(cumV)
        cumPV := 0.0
        cumV  := 0.0
    cumPV += hlc3 * volume
    cumV  += volume
    vwap  = cumV > 0 ? cumPV / cumV : na
    atr   = ta.atr(14)
    band  = atr * qvwapAtrK
    slope = vwap - vwap[1]
    [vwap, band, slope]

// Compute on 4H bars
[qvwap4H, qBand4H, qSlope4H] = request.security(syminfo.tickerid, "240", qvwap_tuple_4H(), barmerge.gaps_off, barmerge.lookahead_off)
close_4H = request.security(syminfo.tickerid, "240", close, barmerge.gaps_off, barmerge.lookahead_off)

// Location vs band
qv_above     = close_4H > (qvwap4H + qBand4H)
qv_below     = close_4H < (qvwap4H - qBand4H)
qv_mid_upper = not qv_above and close_4H >= qvwap4H
qv_mid_lower = not qv_below and close_4H <  qvwap4H

qv_state = qv_above     ? "above" :
           qv_mid_upper ? "mid_to_upper" :
           qv_mid_lower ? "mid_to_lower" : "below"

// Reclaim/loss on 4H
qv_reclaim = close_4H > qvwap4H and close_4H[1] <= nz(qvwap4H[1])
qv_loss    = close_4H < qvwap4H and close_4H[1] >= nz(qvwap4H[1])

// Slope & flat detector aligned to 4H
qv_slopeUp = qSlope4H > 0
qv_slopeDn = qSlope4H < 0

atr4H    = request.security(syminfo.tickerid, "240", ta.atr(14), barmerge.gaps_off, barmerge.lookahead_off)
atrD     = request.security(syminfo.tickerid, "D",   ta.atr(14), barmerge.gaps_off, barmerge.lookahead_off)  // keep for other sections (LTF/EMA scoring)
flatSlope = math.abs(qSlope4H) < (0.05 * atr4H)  // 4H-based flatness

// ───────────────────────── Bias context (Monday) ─────────────────────────

[dDow, dHi, dLo] = request.security(syminfo.tickerid, "D", [dayofweek, high, low], barmerge.gaps_off, barmerge.lookahead_off)
isMon = dDow == dayofweek.monday
monHi = ta.valuewhen(isMon, dHi, 0)
monLo = ta.valuewhen(isMon, dLo, 0)
monInside = useMon and not na(monHi) and not na(monLo) ? (close_D <= monHi and close_D >= monLo) : false
monDevAbove = useMon and not na(monHi) and close_D > monHi
monDevBelow = useMon and not na(monLo) and close_D < monLo
var string mon_state = "inside"
var string mon_state_prev = "inside"
if barstate.isconfirmed
    mon_state_prev := mon_state
    mon_state := not useMon or (na(monHi) or na(monLo)) ? "inside" :
         monDevAbove ? "dev_above" :
         monDevBelow ? "dev_below" : "inside"
    if mon_state_prev != "inside" and mon_state == "inside"
        mon_state := "reclaim_inside"

// 15m Monday sweep helpers (re-entry into range after sweep)
// These read the daily Monday high/low (monHi/monLo) and detect 15m sweeps
mon_hi_swept_15 = request.security(syminfo.tickerid, "15", (high > monHi) and (close <= monHi and close >= monLo), barmerge.gaps_off, barmerge.lookahead_off)
mon_lo_swept_15 = request.security(syminfo.tickerid, "15", (low  < monLo) and (close <= monHi and close >= monLo), barmerge.gaps_off, barmerge.lookahead_off)

// Grace window: allow last 4 x 15m bars (~1h)
barsSinceSweep15 = request.security(syminfo.tickerid, "15", ta.barssince(((high > monHi) and (close <= monHi and close >= monLo)) or ((low  < monLo) and (close <= monHi and close >= monLo))), barmerge.gaps_off, barmerge.lookahead_off)
allowSweep = (barsSinceSweep15 >= 0) and (barsSinceSweep15 <= 4)

// ───────────────────────── Macro TREND v2 — multi‑TF pulse recipe (1H/4H/1D) ─────────────────────────
// Keep daily % change fields for JSON (unchanged shape)
oChg = pct_change_daily(othersSym)
sChg = pct_change_daily(stableSym)

// Quarter‑anchored VWAP tuple on any symbol/TF (used inside request.security)
qvwap_tuple_dom() =>
    var float cumPV = na
    var float cumV  = na
    newM = ta.change(time("M")) != 0
    newQ = newM and (month == 1 or month == 4 or month == 7 or month == 10)
    if newQ or na(cumPV) or na(cumV)
        cumPV := 0.0
        cumV  := 0.0
    cumPV += hlc3 * volume
    cumV  += volume
    vwap  = cumV > 0 ? cumPV / cumV : na
    atr   = ta.atr(14)
    band  = atr * qvwapAtrK
    slope = vwap - vwap[1]
    [vwap, band, slope]

// Dominance structure body (HH/HL/LH/LL) used inside security
dom_struct_body(lb) =>
    ph = ta.pivothigh(high, lb, lb)
    pl = ta.pivotlow (low,  lb, lb)
    lastPH = ta.valuewhen(not na(ph), ph, 0)
    prevPH = ta.valuewhen(not na(ph), ph, 1)
    lastPL = ta.valuewhen(not na(pl), pl, 0)
    prevPL = ta.valuewhen(not na(pl), pl, 1)
    _hh = not na(lastPH) and not na(prevPH) and lastPH > prevPH
    _hl = not na(lastPL) and not na(prevPL) and lastPL > prevPL
    _lh = not na(lastPH) and not na(prevPH) and lastPH < prevPH
    _ll = not na(lastPL) and not na(prevPL) and lastPL < prevPL
    [_hh, _hl, _lh, _ll]

// Instantaneous pulse (+1/0/−1) per TF, computed in that TF
dom_pulse_inst(lb) =>
    e12 = ta.ema(close, 12)
    emaAbove = close > e12
    [vwap, band, slope] = qvwap_tuple_dom()
    q_above     = close > (vwap + band)
    q_below     = close < (vwap - band)
    q_mid_upper = not q_above and close >= vwap
    q_mid_lower = not q_below and close <  vwap
    [hh, hl, lh, ll] = dom_struct_body(lb)
    atr_ = ta.atr(14)
    flat = math.abs(slope) < (0.05 * atr_)  // slope sanity
    longCond  = emaAbove and (q_above or q_mid_upper) and (hh or hl) and not (lh or ll) and slope > 0 and not flat
    shortCond = (not emaAbove) and (q_below or q_mid_lower) and (lh or ll) and not (hh or hl) and slope < 0 and not flat
    longCond ? 1 : shortCond ? -1 : 0

// Per‑TF pulses for OTHERS and STABLES
oth_1h_i = request.security(othersSym, "60",  dom_pulse_inst(lookback), barmerge.gaps_off, barmerge.lookahead_off)
oth_4h_i = request.security(othersSym, "240", dom_pulse_inst(lookback), barmerge.gaps_off, barmerge.lookahead_off)
oth_1d_i = request.security(othersSym, "D",   dom_pulse_inst(lookback), barmerge.gaps_off, barmerge.lookahead_off)

stb_1h_i = request.security(stableSym, "60",  dom_pulse_inst(lookback), barmerge.gaps_off, barmerge.lookahead_off)
stb_4h_i = request.security(stableSym, "240", dom_pulse_inst(lookback), barmerge.gaps_off, barmerge.lookahead_off)
stb_1d_i = request.security(stableSym, "D",   dom_pulse_inst(lookback), barmerge.gaps_off, barmerge.lookahead_off)

// 1H debounce (need two consecutive 1H bars) with Monday reclaim override
overrideMacro1h = useMon and (mon_state == "reclaim_inside") and allowSweep and (((oth_1h_i - stb_1h_i) / 2) != 0)
oth_1h = overrideMacro1h ? oth_1h_i : (oth_1h_i != 0 and oth_1h_i == nz(oth_1h_i[1]) ? oth_1h_i : 0)
stb_1h = overrideMacro1h ? stb_1h_i : (stb_1h_i != 0 and stb_1h_i == nz(stb_1h_i[1]) ? stb_1h_i : 0)

// 4H/1D use instantaneous pulses
oth_4h = oth_4h_i
oth_1d = oth_1d_i
stb_4h = stb_4h_i
stb_1d = stb_1d_i

// Weighted pulses (10% / 30% / 60%)
P_OTHERS  = 0.10 * oth_1h + 0.30 * oth_4h + 0.60 * oth_1d
P_STABLES = 0.10 * stb_1h + 0.30 * stb_4h + 0.60 * stb_1d

// Raw macro rotation in [−2..+2] → 5‑centered rating (every ~0.20 adds ~1 point)
macro_raw    = P_OTHERS - P_STABLES
macro_rating = math.max(1.0, math.min(10.0, 5.0 + 2.5 * macro_raw))
trend_rating = macro_rating  // keep original name for table/UI parity

// Per‑TF net pulse (−1/0/+1) for payload
pulse_1h = math.sign((oth_1h - stb_1h) / 2.0)
pulse_4h = math.sign((oth_4h - stb_4h) / 2.0)
pulse_1d = math.sign((oth_1d - stb_1d) / 2.0)

// Signal with hysteresis (±0.2) + flip margin (|macro_raw| ≥ 0.2)
UP_THR = 6.0
DN_THR = 4.0
HYST   = 0.2
MARG   = 0.2

var string trend_sig = "HOLD"
if trend_sig == "BUY"
    if macro_rating < (UP_THR - HYST) or math.abs(macro_raw) < MARG
        trend_sig := "HOLD"
else if trend_sig == "SELL"
    if macro_rating > (DN_THR + HYST) or math.abs(macro_raw) < MARG
        trend_sig := "HOLD"
else
    if macro_rating >= (UP_THR + HYST) and math.abs(macro_raw) >= MARG
        trend_sig := "BUY"
    else if macro_rating <= (DN_THR - HYST) and math.abs(macro_raw) >= MARG
        trend_sig := "SELL"

// ───────────────────────── Ratings (v1) — daily only ─────────────────────────
// Structure flags
struct_long  = hh_D or hl_D
struct_short = lh_D or ll_D
struct_mixed = (struct_long and struct_short)

// Location credit (guardrail #1: both agree + supportive slope → +0.6; else +0.3)
loc_long_full  = (ema12_state=="above") and (qv_state=="above" or qv_state=="mid_to_upper") and (ema12_slopeUp and qv_slopeUp)
loc_short_full = (ema12_state=="below") and (qv_state=="below" or qv_state=="mid_to_lower") and (ema12_slopeDn and qv_slopeDn)
loc_long_half  = (ema12_state=="above" or (qv_state=="above" or qv_state=="mid_to_upper"))
loc_short_half = (ema12_state=="below" or (qv_state=="below" or qv_state=="mid_to_lower"))

locCred_long  = loc_long_full  ? 0.6 : (loc_long_half  ? 0.3 : 0.0)
locCred_short = loc_short_full ? 0.6 : (loc_short_half ? 0.3 : 0.0)

// Trigger credit (guardrail #2: only if structure is clean)
trig_long  = (rsi_50_up or reg_bull_div) and struct_long  and not struct_mixed
trig_short = (rsi_50_down or reg_bear_div) and struct_short and not struct_mixed

trigCred_long  = trig_long  ? 0.4 : 0.0
trigCred_short = trig_short ? 0.4 : 0.0

// Bias credit (Monday only — DO removed)
biasCred_long  = (useMon and mon_state == "reclaim_inside") ? 0.2 : 0.0
biasCred_short = (useMon and mon_state == "reclaim_inside") ? 0.2 : 0.0

// Macro credit
macroCred_long  = trend_sig == "BUY"  ? macroWeight : 0.0
macroCred_short = trend_sig == "SELL" ? macroWeight : 0.0

// Penalties
pen_chase_long  = (rsiD > rsiOB) ? 0.4 : 0.0
pen_chase_short = (rsiD < rsiOS) ? 0.4 : 0.0
pen_mid_flat    = ((qv_state=="mid_to_upper" or qv_state=="mid_to_lower") and flatSlope) ? 0.4 : 0.0
pen_mixed       = struct_mixed ? 0.6 : 0.0

pen_long  = pen_chase_long  + pen_mid_flat + pen_mixed
pen_short = pen_chase_short + pen_mid_flat + pen_mixed

// Raw component sums
raw_long  = macroCred_long  + (struct_long ? 0.6 : 0.0) + locCred_long  + trigCred_long  + biasCred_long  - pen_long
raw_short = macroCred_short + (struct_short? 0.6 : 0.0) + locCred_short + trigCred_short + biasCred_short - pen_short

// Normalize to 1..10  (range [-1.4, +2.6] → [1,10])
norm(r) =>
    rr = 1.0 + ((r + 1.4) / 4.0) * 9.0
    math.max(1.0, math.min(10.0, math.round(rr*10.0)/10.0))

rating_long  = norm(raw_long)
rating_short = norm(raw_short)

// Decide HTF signal + rating
htf_sig = rating_long > rating_short and rating_long >= 7.5 ? "BUY" :
          rating_short > rating_long and rating_short >= 7.5 ? "SELL" : "HOLD"
htf_rating = htf_sig == "BUY"  ? rating_long :
             htf_sig == "SELL" ? rating_short : math.max(rating_long, rating_short)

// APPEND-ONLY: TF-aware RSI, MP-VWAP, and simple OB classification for LTF indicator-based rating
// Map "1D" -> "D" for security()
rsi_tf_res = rsi_tf == "1D" ? "D" : rsi_tf
ob_tf_res  = ob_tf  == "1D" ? "D" : ob_tf

// TF-aware RSI value
rsi_val = request.security(syminfo.tickerid, rsi_tf_res, ta.rsi(close, rsiLen), barmerge.gaps_off, barmerge.lookahead_off)

// Multi-period anchored VWAP (MP-VWAP) computed on Daily with selectable anchor
mpvwap_calc() =>
    var float cumPV = na
    var float cumV  = na
    newSess = mpvwap_anchor == "W" ? (ta.change(time("W"))  != 0) :
               mpvwap_anchor == "M" ? (ta.change(time("M"))  != 0) :
               mpvwap_anchor == "Q" ? (ta.change(time("3M")) != 0) :
                                      (ta.change(time("12M"))!= 0)
    if newSess or na(cumPV) or na(cumV)
        cumPV := 0.0
        cumV  := 0.0
    cumPV += hlc3 * volume
    cumV  += volume
    cumV > 0 ? cumPV / cumV : na

mpvwapD = request.security(syminfo.tickerid, "D", mpvwap_calc(), barmerge.gaps_off, barmerge.lookahead_off)
mpvwap_above = close_D > mpvwapD

// Simple internal Order Block (OB) heuristic on selected TF
var float ob_lastHigh = na
var float ob_lastLow  = na
// Use a tight 5-bar swing definition for OB pivots
obLen = 5
ob_ph = request.security(syminfo.tickerid, ob_tf_res, ta.pivothigh(high, obLen, obLen), barmerge.gaps_off, barmerge.lookahead_off)
ob_pl = request.security(syminfo.tickerid, ob_tf_res, ta.pivotlow (low,  obLen, obLen), barmerge.gaps_off, barmerge.lookahead_off)
if not na(ob_ph) and ob_ph != ob_lastHigh
    ob_lastHigh := ob_ph
if not na(ob_pl) and ob_pl != ob_lastLow
    ob_lastLow := ob_pl
ob_close     = request.security(syminfo.tickerid, ob_tf_res, close,              barmerge.gaps_off, barmerge.lookahead_off)
// Simple rule per spec: reclaim above last swing high => bullish; loss below last swing low => bearish; else none
string ob_state = "none"
if ob_enabled
    if not na(ob_lastHigh) and ob_close > ob_lastHigh
        ob_state := "bullish"
    else if not na(ob_lastLow) and ob_close < ob_lastLow
        ob_state := "bearish"
    else
        ob_state := "none"
else
    ob_state := "none"

// Indicator scores for LTF rating (normalized)
score_vwap = tanh( (close_D - mpvwapD) / (atrD * kv) )
score_rsi  = math.max(-1.0, math.min(1.0, (rsi_val - 50.0) / 50.0))
score_ema  = tanh( (close_D - ema12_D) / (atrD * ke) )
score_ob   = ob_state == "bullish" ?  1.0 : ob_state == "bearish" ? -1.0 : 0.0

num = (w_vwap * score_vwap) + (w_rsi * score_rsi) + ((useEma12Rate ? w_ema : 0.0) * score_ema) + ((ob_enabled ? w_ob : 0.0) * score_ob)
den = (w_vwap) + (w_rsi) + (useEma12Rate ? w_ema : 0.0) + (ob_enabled ? w_ob : 0.0)
rating_ind = den > 0 ? (5.0 + 5.0 * (num / den)) : 5.0
rating_ind := math.max(0.0, math.min(10.0, rating_ind))

// ===================== LTF rating & signal (5m/15m/60m vote) =====================

// Structure vote (long/short) across 5m, 15m, 60m
lt_votes_long  = (hh_5 or hl_5  ? 1 : 0) + (hh_15 or hl_15 ? 1 : 0) + (hh_60 or hl_60 ? 1 : 0)
lt_votes_short = (lh_5 or ll_5  ? 1 : 0) + (lh_15 or ll_15 ? 1 : 0) + (lh_60 or ll_60 ? 1 : 0)

struct_long_ltf  = lt_votes_long  >= 2
struct_short_ltf = lt_votes_short >= 2
struct_mixed_ltf = struct_long_ltf and struct_short_ltf

// Triggers (reuse daily RSI/div rules but require clean structure)
trig_long_ltf   = (rsi_50_up   or reg_bull_div) and struct_long_ltf  and not struct_mixed_ltf
trig_short_ltf  = (rsi_50_down or reg_bear_div) and struct_short_ltf and not struct_mixed_ltf

trigCred_long_ltf   = trig_long_ltf  ? 0.4 : 0.0
trigCred_short_ltf  = trig_short_ltf ? 0.4 : 0.0

// Penalties (same recipe)
pen_mixed_ltf  = struct_mixed_ltf ? 0.6 : 0.0
pen_long_ltf   = pen_chase_long  + pen_mid_flat + pen_mixed_ltf
pen_short_ltf  = pen_chase_short + pen_mid_flat + pen_mixed_ltf

// Raw component sums (reuse macroCred_*, locCred_*, biasCred_*)
raw_long_ltf  = macroCred_long  + (struct_long_ltf  ? 0.6 : 0.0) + locCred_long  + trigCred_long_ltf  + biasCred_long  - pen_long_ltf
raw_short_ltf = macroCred_short + (struct_short_ltf ? 0.6 : 0.0) + locCred_short + trigCred_short_ltf + biasCred_short - pen_short_ltf

// Normalize to 1..10
ltf_rating_long  = norm(raw_long_ltf)
ltf_rating_short = norm(raw_short_ltf)

// LTF signal (same thresholds as HTF)
ltf_sig = ltf_rating_long > ltf_rating_short and ltf_rating_long >= 7.5 ? "BUY" :
          ltf_rating_short > ltf_rating_long and ltf_rating_short >= 7.5 ? "SELL" : "HOLD"

ltf_rating = ltf_sig == "BUY"  ? ltf_rating_long :
             ltf_sig == "SELL" ? ltf_rating_short : math.max(ltf_rating_long, ltf_rating_short)

// ===================== Deterministic components (HTF & LTF) =====================
// HTF components per spec
pure_long    = struct_long and not struct_short
pure_short   = struct_short and not struct_long
structure_long_det  = struct_mixed ? -0.6 : pure_long  ? 0.6 : 0.0
structure_short_det = struct_mixed ? -0.6 : pure_short ? 0.6 : 0.0

longLocA  = (ema12_state == "above")
longLocB  = (qv_state == "above" or qv_state == "mid_to_upper")
shortLocA = (ema12_state == "below")
shortLocB = (qv_state == "below" or qv_state == "mid_to_lower")
loc_long_det  = (longLocA and longLocB)  ? 0.6 : ((longLocA != longLocB)  ? 0.3 : 0.0)
loc_short_det = (shortLocA and shortLocB) ? 0.6 : ((shortLocA != shortLocB) ? 0.3 : 0.0)

trig_long_det  = (rsi_50_up   or reg_bull_div) ? 0.4 : 0.0
trig_short_det = (rsi_50_down or reg_bear_div) ? 0.4 : 0.0

bias_long_det  = (useMon and mon_state == "reclaim_inside" and mon_state_prev == "dev_below") ? 0.2 : 0.0
bias_short_det = (useMon and mon_state == "reclaim_inside" and mon_state_prev == "dev_above") ? 0.2 : 0.0

midZone = (str.contains(qv_state, "mid"))
pen_long_det  = (rsi_overbought ? -0.4 : 0.0) + (midZone ? -0.2 : 0.0)
pen_short_det = (rsi_oversold   ? -0.4 : 0.0) + (midZone ? -0.2 : 0.0)

clamp10(x) => math.max(1.0, math.min(10.0, math.round(x*10.0)/10.0))
rating_long_det  = clamp10(5.0 + structure_long_det  + loc_long_det  + trig_long_det  + bias_long_det  + pen_long_det)
rating_short_det = clamp10(5.0 + structure_short_det + loc_short_det + trig_short_det + bias_short_det + pen_short_det)

// Signal gating parameters
SIG_THRESH_LTF  = 6.5
SIG_THRESH_HTF  = 6.8
SIG_MARGIN      = 0.3
DEBOUNCE_LTF    = 2
DEBOUNCE_HTF    = 1

// Raw HTF candidate from ratings + margin
string htf_sig_raw = rating_long_det >= SIG_THRESH_HTF and (rating_long_det - rating_short_det) >= SIG_MARGIN ? "BUY" :
                     rating_short_det >= SIG_THRESH_HTF and (rating_short_det - rating_long_det) >= SIG_MARGIN ? "SELL" : "HOLD"

// Debounce state (HTF)
var string htf_sig_det = "HOLD"
var string htf_pending = "HOLD"
var int    htf_pending_count = 0
if htf_sig_raw == htf_sig_det or htf_sig_raw == "HOLD"
    htf_pending := "HOLD"
    htf_pending_count := 0
else
    if htf_pending == htf_sig_raw
        htf_pending_count += 1
    else
        htf_pending := htf_sig_raw
        htf_pending_count := 1
    if htf_pending_count >= DEBOUNCE_HTF
        htf_sig_det := htf_sig_raw
        htf_pending := "HOLD"
        htf_pending_count := 0

// Ratings keep stronger side when HOLD to preserve bias
htf_rating_det = htf_sig_det == "BUY"  ? rating_long_det :
                 htf_sig_det == "SELL" ? rating_short_det : math.max(rating_long_det, rating_short_det)

// LTF components per spec (structure from LTF vote; other pieces reuse daily states)
lt_pure_long  = struct_long_ltf  and not struct_short_ltf
lt_pure_short = struct_short_ltf and not struct_long_ltf
structure_long_ltf_det  = struct_mixed_ltf ? -0.6 : lt_pure_long  ? 0.6 : 0.0
structure_short_ltf_det = struct_mixed_ltf ? -0.6 : lt_pure_short ? 0.6 : 0.0

loc_long_ltf_det  = loc_long_det
loc_short_ltf_det = loc_short_det
trig_long_ltf_det  = trig_long_det
trig_short_ltf_det = trig_short_det
bias_long_ltf_det  = bias_long_det
bias_short_ltf_det = bias_short_det
pen_long_ltf_det   = pen_long_det
pen_short_ltf_det  = pen_short_det

ltf_rating_long_det  = clamp10(5.0 + structure_long_ltf_det  + loc_long_ltf_det  + trig_long_ltf_det  + bias_long_ltf_det  + pen_long_ltf_det)
ltf_rating_short_det = clamp10(5.0 + structure_short_ltf_det + loc_short_ltf_det + trig_short_ltf_det + bias_short_ltf_det + pen_short_ltf_det)

// Raw LTF candidate from ratings + margin
string ltf_sig_raw = ltf_rating_long_det >= SIG_THRESH_LTF and (ltf_rating_long_det - ltf_rating_short_det) >= SIG_MARGIN ? "BUY" :
                     ltf_rating_short_det >= SIG_THRESH_LTF and (ltf_rating_short_det - ltf_rating_long_det) >= SIG_MARGIN ? "SELL" : "HOLD"

// Directional Monday override only bypasses LTF debounce
override_debounce_ltf = useMon and (mon_state == "reclaim_inside") and allowSweep and ((ltf_sig_raw == "BUY" and mon_lo_swept_15) or (ltf_sig_raw == "SELL" and mon_hi_swept_15))

// Debounce state (LTF); directional Monday override can bypass debounce
var string ltf_sig_det = "HOLD"
var string ltf_pending = "HOLD"
var int    ltf_pending_count = 0
if ltf_sig_raw == ltf_sig_det or ltf_sig_raw == "HOLD"
    ltf_pending := "HOLD"
    ltf_pending_count := 0
else
    if override_debounce_ltf
        ltf_sig_det := ltf_sig_raw
        ltf_pending := "HOLD"
        ltf_pending_count := 0
    else
        if ltf_pending == ltf_sig_raw
            ltf_pending_count += 1
        else
            ltf_pending := ltf_sig_raw
            ltf_pending_count := 1
        if ltf_pending_count >= DEBOUNCE_LTF
            ltf_sig_det := ltf_sig_raw
            ltf_pending := "HOLD"
            ltf_pending_count := 0

// Ratings keep stronger side when HOLD to preserve bias
ltf_rating_det = ltf_sig_det == "BUY"  ? ltf_rating_long_det :
                 ltf_sig_det == "SELL" ? ltf_rating_short_det : math.max(ltf_rating_long_det, ltf_rating_short_det)

// Override legacy vars to feed JSON/output with deterministic scheme
htf_sig    := htf_sig_det
htf_rating := htf_rating_det
ltf_sig    := ltf_sig_det
ltf_rating := ltf_rating_det

// ───────────────────────── JSON assembly (original payload + new fields) ─────────────────────────
string oneDExtras = ""
if useDailyVWAP
    oneDExtras := ",\"vwap_reclaim\":" + boolToStr(vwap_reclaim) + ",\"vwap_loss\":" + boolToStr(vwap_loss)

// Keep original RSI keys but switched to real daily values
string rsiExtras = ",\"rsi\":" + str.tostring(rsiD) + ",\"rsi_overbought\":" + boolToStr(rsi_overbought) + ",\"rsi_oversold\":" + boolToStr(rsi_oversold)
// New RSI daily flags in 1D bucket (append-only)
string rsiFlags = ",\"rsi_50_up\":" + boolToStr(rsi_50_up) + ",\"rsi_50_down\":" + boolToStr(rsi_50_down) + ",\"rsi_bull_div\":" + boolToStr(reg_bull_div) + ",\"rsi_bear_div\":" + boolToStr(reg_bear_div)

// Steak tags appended in 1D bucket
string steakFlags = ",\"ema12_state\":\"" + ema12_state + "\",\"qvwap_state\":\"" + qv_state + "\",\"qvwap_tf\":\"240\",\"qvwap_reclaim\":" + boolToStr(qv_reclaim) + ",\"qvwap_loss\":" + boolToStr(qv_loss)

// (added) 5m in mtf
mtf_5   = "\"5\":{\"ema100_state\":\"" + ema_state_5   + "\"," + "\"hh\":" + boolToStr(hh_5)   + "," + "\"hl\":" + boolToStr(hl_5)   + "," + "\"lh\":" + boolToStr(lh_5)   + "," + "\"ll\":" + boolToStr(ll_5)   + "}"
mtf_15  = "\"15\":{\"ema100_state\":\"" + ema_state_15  + "\"," + "\"hh\":" + boolToStr(hh_15)  + "," + "\"hl\":" + boolToStr(hl_15)  + "," + "\"lh\":" + boolToStr(lh_15)  + "," + "\"ll\":" + boolToStr(ll_15)  + "}"
mtf_60  = "\"60\":{\"ema100_state\":\"" + ema_state_60  + "\"," + "\"hh\":" + boolToStr(hh_60)  + "," + "\"hl\":" + boolToStr(hl_60)  + "," + "\"lh\":" + boolToStr(lh_60)  + "," + "\"ll\":" + boolToStr(ll_60)  + "}"
mtf_240 = "\"240\":{\"ema100_state\":\"" + ema_state_240 + "\"," + "\"hh\":" + boolToStr(hh_240) + "," + "\"hl\":" + boolToStr(hl_240) + "," + "\"lh\":" + boolToStr(lh_240) + "," + "\"ll\":" + boolToStr(ll_240) + "}"
mtf_1D  = "\"1D\":{\"ema100_state\":\"" + ema_state_D   + "\"," + "\"hh\":" + boolToStr(hh_D)   + "," + "\"hl\":" + boolToStr(hl_D)   + "," + "\"lh\":" + boolToStr(lh_D)   + "," + "\"ll\":" + boolToStr(ll_D)   + "," + "\"ema12_reclaim\":" + boolToStr(ema12_reclaim) + "," + "\"ema12_loss\":" + boolToStr(ema12_loss) + steakFlags + oneDExtras + rsiExtras + rsiFlags + "}"

isFresh = "true"  // snapshot emitted once per bar close
ctxStr  = "\"ctx\":{\"above_do\":null,\"mon_state\":\"" + (useMon ? mon_state : "inside") + "\"}"
// Restore daily %-change fields for JSON (payload expects these) — reuse existing ids
oChg := pct_change_daily(othersSym)
sChg := pct_change_daily(stableSym)
trendStr = "\"trend\":{" + "\"sig\":\"" + trend_sig + "\",\"source\":\"OTHERS_vs_STABLE\",\"others_d_change\":" +
           str.tostring(oChg) + ",\"stable_d_change\":" + str.tostring(sChg) + ",\"rating\":" +
           (na(trend_rating) ? "null" : fmt1(trend_rating)) + "}"

// Dominant side for component printing (avoid zeros on HOLD)
string htf_side = htf_sig != "HOLD" ? htf_sig : (rating_long_det >= rating_short_det ? "BUY" : "SELL")
string ltf_side = ltf_sig != "HOLD" ? ltf_sig : (ltf_rating_long_det >= ltf_rating_short_det ? "BUY" : "SELL")

// Shared HTF components (deterministic numbers; macro informational only under trend{})
compStr = "\"components\":{" +
          "\"structure\":" + fmt1(htf_side=="BUY"?structure_long_det:htf_side=="SELL"?structure_short_det:0.0) + "," +
          "\"location\":" + fmt1(htf_side=="BUY"?loc_long_det:htf_side=="SELL"?loc_short_det:0.0) + "," +
          "\"trigger\":" + fmt1(htf_side=="BUY"?trig_long_det:htf_side=="SELL"?trig_short_det:0.0) + "," +
          "\"bias\":" + fmt1(htf_side=="BUY"?bias_long_det:htf_side=="SELL"?bias_short_det:0.0) + "," +
          "\"penalty\":" + fmt1(htf_side=="BUY"?pen_long_det:htf_side=="SELL"?pen_short_det:0.0) + "}"

// LTF-specific components (deterministic)
compStr_ltf = "\"components\":{" +
           "\"structure\":" + fmt1(ltf_side=="BUY"?structure_long_ltf_det:ltf_side=="SELL"?structure_short_ltf_det:0.0) + "," +
           "\"location\":" + fmt1(ltf_side=="BUY"?loc_long_ltf_det:ltf_side=="SELL"?loc_short_ltf_det:0.0) + "," +
           "\"trigger\":" + fmt1(ltf_side=="BUY"?trig_long_ltf_det:ltf_side=="SELL"?trig_short_ltf_det:0.0) + "," +
           "\"bias\":" + fmt1(ltf_side=="BUY"?bias_long_ltf_det:ltf_side=="SELL"?bias_short_ltf_det:0.0) + "," +
           "\"penalty\":" + fmt1(ltf_side=="BUY"?pen_long_ltf_det:ltf_side=="SELL"?pen_short_ltf_det:0.0) + "}"

// APPEND-ONLY: Indicator capsule under ltf.comp.ind
indStr = "\"comp\":{\"ind\":{" +
         "\"mpvwap\":{\"anchor\":\"" + mpvwap_anchor + "\",\"v\":" + str.tostring(mpvwapD, format.mintick) + ",\"above\":" + boolToStr(mpvwap_above) + "}," +
         "\"rsi\":{\"tf\":\"" + rsi_tf + "\",\"len\":" + str.tostring(rsiLen) + ",\"v\":" + str.tostring(rsi_val, format.mintick) + "}," +
         "\"ema12_1d\":{\"v\":" + str.tostring(ema12_D, format.mintick) + ",\"above\":" + boolToStr(ema12_state=="above") + "}," +
         "\"ob\":{\"enabled\":" + boolToStr(ob_enabled) + ",\"tf\":\"" + ob_tf + "\",\"state\":\"" + ob_state + "\"}" +
         "}}"

// Final HTF/LTF objects
htfStr = "\"htf\":{" + "\"sig\":\"" + htf_sig + "\",\"rating\":" + fmt1(htf_rating) + "," + compStr + "}"
// FIX: components are now INSIDE ltf{} and object closes once
// APPEND-ONLY: keep existing rating math (v100 parity); only append comp.ind capsule
ltfStr = "\"ltf\":{" + "\"sig\":\"" + ltf_sig + "\",\"rating\":" + fmt1(ltf_rating) + "," + compStr_ltf + "," + indStr + "}"

// Final payload (production)
string commonCore = "\"symbol\":\"" + syminfo.ticker + "\"," + "\"tf_active\":\"" + timeframe.period + "\"," + "\"ts\":" + str.tostring(time) + "," + "\"cmp\":" + str.tostring(close, format.mintick) + "," + "\"is_fresh\":" + isFresh + "," + "\"mtf\":{" + mtf_5 + "," + mtf_15 + "," + mtf_60 + "," + mtf_240 + "," + mtf_1D + "}" + "," + ctxStr + "," + trendStr + "," + htfStr + "," + ltfStr
payload = "{" + "\"type\":\"WWASD_STATE\"," + commonCore + "}"

// (debug payload removed per request; production payload only)

// ───────────────────────── Alerts ─────────────────────────

// Original per-bar snapshot alert (unchanged type / route behavior)
alertcondition(barstate.isconfirmed, title="WWASD Fire (per bar close)")
if barstate.isconfirmed
    alert(payload, alert.freq_once_per_bar_close)

// RSI events (optional, low-spam; daily only)
new_rsi50_up   = barstate.isconfirmed and rsi_50_up
new_rsi50_down = barstate.isconfirmed and rsi_50_down
new_bull_div   = barstate.isconfirmed and reg_bull_div
new_bear_div   = barstate.isconfirmed and reg_bear_div

rsi_evt = "{\"type\":\"WWASD_RSI_EVENT\",\"symbol\":\"" + syminfo.ticker + "\",\"tf\":\"1D\",\"evt\":\""
if new_rsi50_up
    alert(rsi_evt + "RSI_50_UP\"}", alert.freq_once_per_bar_close)
if new_rsi50_down
    alert(rsi_evt + "RSI_50_DOWN\"}", alert.freq_once_per_bar_close)
if new_bull_div
    alert(rsi_evt + "BULL_DIV\"}", alert.freq_once_per_bar_close)
if new_bear_div
    alert(rsi_evt + "BEAR_DIV\"}", alert.freq_once_per_bar_close)

// A+ candidate gate (dedupe 3 daily bars by default)
dIndex = request.security(syminfo.tickerid, "D", bar_index, barmerge.gaps_off, barmerge.lookahead_off)
var int lastA_Long  = na
var int lastA_Short = na
canEmitLong  = na(lastA_Long)  or (dIndex - lastA_Long  >= dedupeBarsD)
canEmitShort = na(lastA_Short) or (dIndex - lastA_Short >= dedupeBarsD)
aplus_long  = htf_sig=="BUY"  and (ltf_sig=="BUY"  or new_rsi50_up   or new_bull_div) and (useMon and mon_state=="reclaim_inside")
aplus_short = htf_sig=="SELL" and (ltf_sig=="SELL" or new_rsi50_down or new_bear_div) and (useMon and mon_state=="reclaim_inside")

if barstate.isconfirmed and aplus_long and canEmitLong
    lastA_Long := dIndex
    alert("{\"type\":\"WWASD_A_PLUS\",\"symbol\":\"" + syminfo.ticker + "\",\"dir\":\"LONG\",\"rating\":" + fmt1(htf_rating) + "}", alert.freq_once_per_bar_close)
if barstate.isconfirmed and aplus_short and canEmitShort
    lastA_Short := dIndex
    alert("{\"type\":\"WWASD_A_PLUS\",\"symbol\":\"" + syminfo.ticker + "\",\"dir\":\"SHORT\",\"rating\":" + fmt1(htf_rating) + "}", alert.freq_once_per_bar_close)
