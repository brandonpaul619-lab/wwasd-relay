//@version=6
indicator("Risk Regime — (Macro TREND • Q‑VWAP • EMA12)", shorttitle="RISK_REGIME",
     overlay=true, scale=scale.none, max_labels_count=500, max_lines_count=500)

// ─────────────────────────────────────── Inputs (minimal UI) ───────────────────────────────────────
group_sym    = "Symbols"
othersSym    = input.symbol("CRYPTOCAP:OTHERS.D",   "OTHERS Dominance (OTHERS.D)",   group=group_sym)
stableSym    = input.symbol("CRYPTOCAP:STABLE.C.D", "Stable Dominance (STABLE.C.D)", group=group_sym)

group_cfg    = "Config"
mvwapAnchor  = input.string("Quarterly 4H", "VWAP Anchor", options=["Monthly D", "Quarterly 4H"], group=group_cfg)

// ───────────────── Signal Gating (split thresholds) ─────────────────
group_gate   = "Signal Gating"
ltfSigThr    = input.float(6.7, "LTF rating threshold", minval=5.0, maxval=9.9, step=0.1, group=group_gate)
htfSigThr    = input.float(6.9, "HTF rating threshold", minval=5.0, maxval=9.9, step=0.1, group=group_gate)

group_ui     = "Display"
showTable    = input.bool(true, "Show mini table", group=group_ui)
tablePos     = input.string(defval="OG top-right", title="Mini Table Position", options=["OG top-right","Top-center"], group=group_ui)
f__radar_pos() =>
    tablePos == "OG top-right" ? position.top_right : position.top_center

// ─────────────────────────────────── Internal constants (no UI) ────────────────────────────────────
var int   lookbackPivot = 20
var float macroDead     = 0.20     // dead‑zone for OTHERS−STABLES % diff
var float mvwapAtrK     = 0.50     // ATR band factor for anchored VWAP
var string macroRSISym  = "CRYPTOCAP:TOTAL3"
var int    macroRSILen  = 14
var float  macroRSIpts  = 0.30     // ±0.30 max nudge
var float  tanhDiv      = 10.0     // tanh divisor for RSI nudge

// ─────────────────────────────────────────── Helpers ────────────────────────────────────────────────
fmt1(x) => str.tostring(math.round(x*10.0)/10.0)
clamp10(x) => math.max(1.0, math.min(10.0, math.round(x*10.0)/10.0))
boolI(b) => b ? 1 : 0

// bounded tanh (portable)
tanhN(x) =>
    e2 = math.exp(2.0 * x)
    (e2 - 1.0) / (e2 + 1.0)

// % change helper on a TF (single expression prevents continuation issues)
pct_change_tf(sym, tf) =>
    request.security(symbol=sym, timeframe=tf,expression=na(close) or na(close[1]) or close[1]==0 ? 0.0 : ((close - close[1]) / close[1]) * 100.0,gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)

// dead‑zone gate → {−1,0,+1}
sgn_gate(x, dz) => x >  dz ?  1 : x < -dz ? -1 : 0

// Structure body for HH/HL/LH/LL (used in fixed‑TF requests)
struct_body(lb) =>
    ph = ta.pivothigh(high, lb, lb)
    pl = ta.pivotlow (low,  lb, lb)
    lastPH = ta.valuewhen(not na(ph), ph, 0)
    prevPH = ta.valuewhen(not na(ph), ph, 1)
    lastPL = ta.valuewhen(not na(pl), pl, 0)
    prevPL = ta.valuewhen(not na(pl), pl, 1)
    _hh = not na(lastPH) and not na(prevPH) and lastPH > prevPH
    _hl = not na(lastPL) and not na(prevPL) and lastPL > prevPL
    _lh = not na(lastPH) and not na(prevPH) and lastPH < prevPH
    _ll = not na(lastPL) and not na(prevPL) and lastPL < prevPL
    [_hh, _hl, _lh, _ll]

struct_tuple(tf, lb) =>
    request.security(symbol=syminfo.tickerid, timeframe=tf, expression=struct_body(lb),gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)

// ════════════════════════════════ Macro TREND (OTHERS − STABLES) ════════════════════════════════
// 1) Per‑TF pulses (fixed TFs; TF‑independent of chart)
o_1h = pct_change_tf(othersSym, "60")
o_4h = pct_change_tf(othersSym, "240")
o_1d = pct_change_tf(othersSym, "D")

s_1h = pct_change_tf(stableSym, "60")
s_4h = pct_change_tf(stableSym, "240")
s_1d = pct_change_tf(stableSym, "D")

d_1h = o_1h - s_1h
d_4h = o_4h - s_4h
d_1d = o_1d - s_1d

p_1h = sgn_gate(d_1h, macroDead)
p_4h = sgn_gate(d_4h, macroDead)
p_1d = sgn_gate(d_1d, macroDead)

// 2) Weighted pulses → macro_raw ∈ [−2..+2], 5‑centered rating, then smoothed (2‑bar EMA)
macro_raw  = 2.0 * (0.10 * p_1h + 0.30 * p_4h + 0.60 * p_1d)     // risk‑on when OTHERS↑ & STABLES↓
rating_raw = 5.0 + 2.5 * macro_raw
rating_s   = ta.ema(rating_raw, 2)

// 3) TOTAL3 (daily) RSI nudge, applied **after** smoothing; halved in dead‑zone
rsiMacroD  = request.security(symbol=macroRSISym, timeframe="D",
                              expression=ta.rsi(close, macroRSILen),
                              gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
adj_total3 = macroRSIpts * tanhN((rsiMacroD - 50.0) / tanhDiv)
if math.abs(macro_raw) == 0.0 or math.abs(rating_s - 5.0) < 0.2
    adj_total3 := adj_total3 * 0.2

// 4) Final TREND rating and LONG/SHORT/HOLD (with ±0.2 hysteresis + |macro_raw| margin)
trend_rating = clamp10(rating_s + adj_total3)

UP_THR = 6.0
DN_THR = 4.0
HYST   = 0.2
MARG   = 0.2

var string trend_sig = "HOLD"
if trend_sig == "BUY"
    if trend_rating < (UP_THR - HYST) or math.abs(macro_raw) < MARG
        trend_sig := "HOLD"
else if trend_sig == "SELL"
    if trend_rating > (DN_THR + HYST) or math.abs(macro_raw) < MARG
        trend_sig := "HOLD"
else
    if trend_rating >= (UP_THR + HYST) and math.abs(macro_raw) >= MARG
        trend_sig := "BUY"
    else if trend_rating <= (DN_THR - HYST) and math.abs(macro_raw) >= MARG
        trend_sig := "SELL"

trend_sig_txt = trend_sig == "BUY" ? "LONG" : trend_sig == "SELL" ? "SHORT" : "HOLD"

// ───────────────────────────── Daily states (EMA12 • Anchored VWAP) ────────────────────────────────
// EMA‑12 (1D) state & slope — used for LTF/HTF location logic, not in TREND math
[close_D, ema12_D, ema12_D_1] = request.security(symbol=syminfo.tickerid, timeframe="D",expression=[close, ta.ema(close, 12), ta.ema(close, 12)[1]],gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
ema12_state   = close_D > ema12_D ? "above" : "below"
ema12_slopeUp = ema12_D > ema12_D_1
ema12_slopeDn = ema12_D < ema12_D_1

// Monthly‑anchored VWAP (on D)
mvwap_tuple_D() =>
    var float cumPV = na
    var float cumV  = na
    newM = ta.change(time("M")) != 0
    if newM or na(cumPV) or na(cumV)
        cumPV := 0.0
        cumV  := 0.0
    cumPV += hlc3 * volume
    cumV  += volume
    vwap  = cumV > 0 ? cumPV / cumV : na
    atr   = ta.atr(14)
    band  = atr * mvwapAtrK
    slope = vwap - vwap[1]
    [vwap, band, slope]

// Quarterly‑anchored VWAP (on 4H; Jan/Apr/Jul/Oct resets)
qvwap_tuple_4H() =>
    var float cumPV = na
    var float cumV  = na
    newM = ta.change(time("M")) != 0
    newQ = newM and (month == 1 or month == 4 or month == 7 or month == 10)
    if newQ or na(cumPV) or na(cumV)
        cumPV := 0.0
        cumV  := 0.0
    cumPV += hlc3 * volume
    cumV  += volume
    vwap  = cumV > 0 ? cumPV / cumV : na
    atr   = ta.atr(14)
    band  = atr * mvwapAtrK
    slope = vwap - vwap[1]
    [vwap, band, slope]

// Fetch both flavors; select via input
[mvwapD,  mBandD,  mSlopeD]  = request.security(symbol=syminfo.tickerid, timeframe="D",   expression=mvwap_tuple_D(),  gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
[qvwap4h, qBand4h, qSlope4h] = request.security(symbol=syminfo.tickerid, timeframe="240", expression=qvwap_tuple_4H(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
close_4H = request.security(symbol=syminfo.tickerid, timeframe="240", expression=close,   gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)

useQ   = mvwapAnchor == "Quarterly 4H"
vwapX  = useQ ? qvwap4h : mvwapD
bandX  = useQ ? qBand4h : mBandD
slopeX = useQ ? qSlope4h : mSlopeD
refX   = useQ ? close_4H : close_D

mv_above     = refX > (vwapX + bandX)
mv_below     = refX < (vwapX - bandX)
mv_mid_upper = not mv_above and refX >= vwapX
mv_mid_lower = not mv_below and refX <  vwapX

mv_state = mv_above ? "above" :
          mv_mid_upper ? "mid_to_upper" :
          mv_mid_lower ? "mid_to_lower" : "below"

atr_sel   = request.security(symbol=syminfo.tickerid, timeframe=(useQ ? "240" : "D"), expression=ta.atr(14), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
flatSlope = math.abs(slopeX) < (0.05 * atr_sel)  // flat if <~5% ATR

// ───────────────────────────── LTF (5/30/60) & HTF (4H/12H/1D) structure ────────────────────────────
[hh_5,  hl_5,  lh_5,  ll_5 ] = struct_tuple("5",   lookbackPivot)
[hh_30, hl_30, lh_30, ll_30] = struct_tuple("30",  lookbackPivot)
[hh_60, hl_60, lh_60, ll_60] = struct_tuple("60",  lookbackPivot)

[hh_4h, hl_4h, lh_4h, ll_4h] = struct_tuple("240", lookbackPivot)
[hh_12h,hl_12h,lh_12h,ll_12h]= struct_tuple("720", lookbackPivot)
[hh_1d, hl_1d, lh_1d, ll_1d] = struct_tuple("D",   lookbackPivot)

lt_votes_long  = (boolI(hh_5 or hl_5) + boolI(hh_30 or hl_30) + boolI(hh_60 or hl_60))
lt_votes_short = (boolI(lh_5 or ll_5) + boolI(lh_30 or ll_30) + boolI(lh_60 or ll_60))
ht_votes_long  = (boolI(hh_4h or hl_4h) + boolI(hh_12h or hl_12h) + boolI(hh_1d or hl_1d))
ht_votes_short = (boolI(lh_4h or ll_4h) + boolI(lh_12h or ll_12h) + boolI(lh_1d or ll_1d))

struct_long_ltf   = lt_votes_long  >= 2
struct_short_ltf  = lt_votes_short >= 2
struct_mixed_ltf  = struct_long_ltf and struct_short_ltf

struct_long_htf   = ht_votes_long  >= 2
struct_short_htf  = ht_votes_short >= 2
struct_mixed_htf  = struct_long_htf and struct_short_htf

// ───────────────────────────── Ratings (NO RSI in LTF/HTF) ──────────────────────────────────────────
// Location credits (EMA12 + anchored VWAP)
loc_long_full  = (ema12_state=="above") and (mv_state=="above" or mv_state=="mid_to_upper") and (ema12_slopeUp and (slopeX > 0))
loc_short_full = (ema12_state=="below") and (mv_state=="below" or mv_state=="mid_to_lower") and (ema12_slopeDn and (slopeX < 0))
loc_long_half  = (ema12_state=="above") or (mv_state=="above" or mv_state=="mid_to_upper")
loc_short_half = (ema12_state=="below") or (mv_state=="below" or mv_state=="mid_to_lower")

locCred_long  = loc_long_full  ? 0.6 : (loc_long_half  ? 0.3 : 0.0)
locCred_short = loc_short_full ? 0.6 : (loc_short_half ? 0.3 : 0.0)

// Penalty: mid‑zone with flat slope
pen_mid_flat = ((mv_state=="mid_to_upper" or mv_state=="mid_to_lower") and flatSlope) ? 0.4 : 0.0

// HTF raw scores (structure + location − penalty)
struct_long_htf_pure  = struct_long_htf and not struct_short_htf
struct_short_htf_pure = struct_short_htf and not struct_long_htf
structure_long_htf    = struct_mixed_htf ? -0.6 : (struct_long_htf_pure  ? 0.6 : 0.0)
structure_short_htf   = struct_mixed_htf ? -0.6 : (struct_short_htf_pure ? 0.6 : 0.0)
pen_long_htf  = pen_mid_flat
pen_short_htf = pen_mid_flat
raw_long_htf  = structure_long_htf  + locCred_long  - pen_long_htf
raw_short_htf = structure_short_htf + locCred_short - pen_short_htf

// LTF raw scores (structure votes + same location/penalty)
struct_long_ltf_pure  = struct_long_ltf and not struct_short_ltf
struct_short_ltf_pure = struct_short_ltf and not struct_long_ltf
structure_long_ltf    = struct_mixed_ltf ? -0.6 : (struct_long_ltf_pure  ? 0.6 : 0.0)
structure_short_ltf   = struct_mixed_ltf ? -0.6 : (struct_short_ltf_pure ? 0.6 : 0.0)
pen_long_ltf  = pen_mid_flat
pen_short_ltf = pen_mid_flat
raw_long_ltf  = structure_long_ltf  + locCred_long  - pen_long_ltf
raw_short_ltf = structure_short_ltf + locCred_short - pen_short_ltf

// Normalize (empirical map [-1.4..+2.6] → [1..10])
norm(r) =>
    rr = 1.0 + ((r + 1.4) / 4.0) * 9.0
    clamp10(rr)

htf_rating_long  = norm(raw_long_htf)
htf_rating_short = norm(raw_short_htf)
ltf_rating_long  = norm(raw_long_ltf)
ltf_rating_short = norm(raw_short_ltf)

// Decide HTF signal + rating (uses stricter HTF threshold)
htf_sig = htf_rating_long > htf_rating_short and htf_rating_long >= htfSigThr ? "BUY" :
          htf_rating_short > htf_rating_long and htf_rating_short >= htfSigThr ? "SELL" : "HOLD"

// Decide LTF signal + rating (uses more permissive LTF threshold)
ltf_sig = ltf_rating_long > ltf_rating_short and ltf_rating_long >= ltfSigThr ? "BUY" :
          ltf_rating_short > ltf_rating_long and ltf_rating_short >= ltfSigThr ? "SELL" : "HOLD"

htf_rating = htf_sig == "BUY"  ? htf_rating_long :
             htf_sig == "SELL" ? htf_rating_short : math.max(htf_rating_long, htf_rating_short)
ltf_rating = ltf_sig == "BUY"  ? ltf_rating_long :
             ltf_sig == "SELL" ? ltf_rating_short : math.max(ltf_rating_long, ltf_rating_short)

// ────────────────────────────────────────── Mini Table ──────────────────────────────────────────────
colUp   = color.new(color.lime,  0)
colDown = color.new(color.rgb(139,0,0), 0)
colHold = color.new(color.white, 0)
lab_col(lbl) => lbl == "BUY" or lbl == "LONG" ? colUp : (lbl == "SELL" or lbl == "SHORT" ? colDown : colHold)

tableBg = color.new(color.rgb(22,13,13), 70)
var table t = na
if showTable and na(t)
    t := table.new(position=f__radar_pos(), columns=4, rows=4, bgcolor=tableBg,
                   frame_color=color.white, frame_width=1, border_color=tableBg, border_width=1)

if showTable and barstate.islast
    colSpc = 3
    padTxt = "        "
    // pad row
    table.cell(t, 0, 0, padTxt, text_color=tableBg, bgcolor=tableBg, text_size=size.small)
    table.cell(t, 1, 0, padTxt, text_color=tableBg, bgcolor=tableBg, text_size=size.small)
    table.cell(t, 2, 0, padTxt, text_color=tableBg, bgcolor=tableBg, text_size=size.small)
    table.cell(t, colSpc, 0, padTxt, text_color=tableBg, bgcolor=tableBg, text_size=size.small)
    // LTF
    table.cell(t, 0, 1, "LTF (5m/30m/60m)", text_color=color.white, bgcolor=tableBg, text_size=size.small, text_halign=text.align_left)
    table.cell(t, 1, 1, fmt1(ltf_rating),   text_color=color.white, bgcolor=tableBg, text_size=size.small)
    table.cell(t, 2, 1, ltf_sig,            text_color=lab_col(ltf_sig), bgcolor=tableBg, text_size=size.small)
    table.cell(t, colSpc, 1, padTxt,        text_color=tableBg, bgcolor=tableBg, text_size=size.small)
    // HTF
    table.cell(t, 0, 2, "HTF (4h/12h/1d)",  text_color=color.white, bgcolor=tableBg, text_size=size.small, text_halign=text.align_left)
    table.cell(t, 1, 2, fmt1(htf_rating),   text_color=color.white, bgcolor=tableBg, text_size=size.small)
    table.cell(t, 2, 2, htf_sig,            text_color=lab_col(htf_sig), bgcolor=tableBg, text_size=size.small)
    table.cell(t, colSpc, 2, padTxt,        text_color=tableBg, bgcolor=tableBg, text_size=size.small)
    // TREND
    table.cell(t, 0, 3, "TREND (OTHERS/STABLE)", text_color=color.white, bgcolor=tableBg, text_size=size.small, text_halign=text.align_left)
    table.cell(t, 1, 3, fmt1(trend_rating),      text_color=color.white, bgcolor=tableBg, text_size=size.small)
    table.cell(t, 2, 3, trend_sig_txt,           text_color=lab_col(trend_sig_txt), bgcolor=tableBg, text_size=size.small)
    table.cell(t, colSpc, 3, padTxt,             text_color=tableBg, bgcolor=tableBg, text_size=size.small)

